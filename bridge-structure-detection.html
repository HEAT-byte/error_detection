<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>基于多传感器时空协同学习的桥梁异常信息智能提取系统</title>
    <!-- 添加网页图标 -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>🌉</text></svg>">
    <!-- 本地资源修复脚本 - 最先加载 -->
    <script src="js/local-resources-fix.js"></script>
    <!-- Material Icons库 - 本地版本 -->
    <link href="css/material-icons.css" rel="stylesheet">
    <!-- 服务器兼容性脚本 - 必须最先加载 -->
    <script src="js/server-compatibility.js"></script>
    <!-- Chart.js库 - 本地版本 - 使用async=false确保同步加载 -->
    <script src="js/chart.min.js" async="false"></script>
    <!-- Chart.js紧急修复脚本 - 在Chart定义后立即加载 -->
    <script src="js/chart-fix.js"></script>
    <!-- Chart.js备用实现 - 确保Chart对象始终可用 -->
    <script src="js/chart-fallback.js"></script>
    <!-- 引入Chart.js库用于数据可视化 -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- 引入Material Icons库 -->
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <style>
        body {
            font-family: "Microsoft YaHei", Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f7f9fc;
            color: #333;
        }
        .header {
            background: linear-gradient(135deg, #2c5282, #1a365d);
            color: white;
            padding: 20px 20px;
            text-align: center;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        .header h1 {
            margin: 0;
            font-size: 28px;
            letter-spacing: 1px;
            margin-bottom: 10px;
        }
        .header-subtitle {
            font-size: 14px;
            opacity: 0.8;
            margin-bottom: 15px;
        }
        .user-info {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 5px;
        }
        .user-avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background-color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #2c5282;
            font-weight: bold;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .logout-btn {
            background-color: rgba(255,255,255,0.2);
            border: none;
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        .logout-btn:hover {
            background-color: rgba(255,255,255,0.3);
        }
        /* 登录模态框样式 */
        .login-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
        }
        
        .login-container {
            background-color: white;
            border-radius: 12px;
            padding: 35px;
            width: 380px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            animation: fadeIn 0.5s ease-out;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .login-header {
            text-align: center;
            margin-bottom: 35px;
        }
        
        .login-header h2 {
            color: #2c5282;
            margin: 0 0 10px 0;
            font-size: 24px;
        }
        
        .login-header p {
            color: #718096;
            margin: 5px 0 0 0;
            font-size: 14px;
        }
        
        .login-form .form-group {
            margin-bottom: 25px;
        }
        
        .login-form label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #4a5568;
            font-size: 14px;
        }
        
        .login-form input {
            width: 100%;
            padding: 12px 15px;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            font-size: 16px;
            transition: all 0.3s;
            box-sizing: border-box;
        }
        
        .login-form input:focus {
            outline: none;
            border-color: #4299e1;
            box-shadow: 0 0 0 3px rgba(66, 153, 225, 0.2);
        }
        
        .login-form .login-button {
            background-color: #2c5282;
            color: white;
            padding: 12px 15px;
            border: none;
            border-radius: 6px;
            width: 100%;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s;
            margin-top: 10px;
        }
        
        .login-form .login-button:hover {
            background-color: #2b6cb0;
            transform: translateY(-2px);
        }
        
        .login-form .login-button:active {
            transform: translateY(0);
        }
        
        .error-message {
            color: #e53e3e;
            margin-top: 15px;
            text-align: center;
            font-size: 14px;
            font-weight: 500;
            min-height: 20px;
        }
        /* 桥梁示意图样式 */
        .bridge-container {
            margin-top: 20px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background-color: #f8f9fa;
            position: relative;
            height: 300px;
            overflow: hidden;
        }
        .bridge {
            position: relative;
            height: 100%;
            width: 100%;
        }
        .bridge-deck {
            position: absolute;
            bottom: 120px;
            left: 5%;
            width: 90%;
            height: 20px;
            background-color: #6c757d;
        }
        .bridge-pier {
            position: absolute;
            bottom: 0;
            width: 40px;
            height: 120px;
            background-color: #495057;
        }
        .bridge-pier:nth-child(1) {
            left: 10%;
        }
        .bridge-pier:nth-child(2) {
            left: 50%;
            transform: translateX(-50%);
        }
        .bridge-pier:nth-child(3) {
            right: 10%;
        }
        .sensor-point {
            position: absolute;
            width: 15px;
            height: 15px;
            border-radius: 50%;
            background-color: #28a745;
            border: 2px solid white;
            transform: translate(-50%, -50%);
            transition: all 0.3s;
            cursor: pointer;
        }
        .sensor-point:hover {
            transform: translate(-50%, -50%) scale(1.2);
            z-index: 10;
        }
        .sensor-point.warning {
            background-color: #ffc107;
        }
        .sensor-point.danger {
            background-color: #dc3545;
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0% { opacity: 0.8; }
            50% { opacity: 0.4; }
            100% { opacity: 0.8; }
        }
        .sensor-tooltip {
            position: absolute;
            background-color: rgba(0,0,0,0.8);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            z-index: 100;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            white-space: nowrap;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            position: relative;
            padding-bottom: 60px; /* 增加底部间距，为项目信息留出空间 */
        }
        .card {
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.08);
            padding: 24px;
            margin-bottom: 24px;
            transition: transform 0.2s, box-shadow 0.2s;
            border: 1px solid rgba(0,0,0,0.03);
        }
        .card:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.1);
        }
        .card-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 18px;
            color: #2c5282;
            border-bottom: 1px solid #edf2f7;
            padding-bottom: 12px;
            display: flex;
            align-items: center;
        }
        .card-title::before {
            content: "";
            display: inline-block;
            width: 4px;
            height: 18px;
            background-color: #2c5282;
            margin-right: 10px;
            border-radius: 2px;
        }
        .example-file-link {
            margin-top: 12px;
            display: block;
            font-size: 14px;
            color: #2c5282;
            text-decoration: none;
            padding: 8px 12px;
            border-radius: 6px;
            background-color: #edf2f7;
            transition: all 0.2s;
            width: fit-content;
        }
        .example-file-link:hover {
            background-color: #e2e8f0;
            text-decoration: none;
            transform: translateY(-2px);
        }
        .file-format-info {
            background-color: #f8fafc;
            padding: 15px;
            margin-top: 15px;
            border-radius: 8px;
            font-size: 13px;
            border-left: 3px solid #2c5282;
        }
        .upload-area {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        .file-input-container {
            position: relative;
            margin-right: 15px;
            margin-bottom: 10px;
        }
        .custom-file-input {
            background-color: #f0f0f0;
            border: 1px solid #ddd;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            display: inline-block;
        }
        .custom-file-input:hover {
            background-color: #e0e0e0;
        }
        #fileInput {
            position: absolute;
            top: 0;
            left: 0;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }
        .button {
            background-color: #2c5282;
            color: white;
            padding: 10px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            margin-right: 10px;
            margin-bottom: 10px;
            transition: all 0.2s;
            font-weight: 500;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.08);
        }
        .button:hover {
            background-color: #3182ce;
            transform: translateY(-2px);
            box-shadow: 0 4px 6px rgba(0,0,0,0.12);
        }
        .button:active {
            transform: translateY(0);
        }
        .button.secondary {
            background-color: #718096;
        }
        .button.secondary:hover {
            background-color: #4a5568;
        }
        .button.danger {
            background-color: #e53e3e;
        }
        .button.danger:hover {
            background-color: #c53030;
        }
        .button .material-icons {
            font-size: 16px;
            margin-right: 6px;
        }
        .button:disabled {
            background-color: #cbd5e0;
            color: #718096;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        .data-table-container {
            overflow-x: auto;
            margin-bottom: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }
        .data-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
        }
        .data-table th, .data-table td {
            border: 1px solid #edf2f7;
            padding: 10px 14px;
            text-align: left;
        }
        .data-table th {
            background-color: #f8fafc;
            font-weight: 600;
            color: #4a5568;
        }
        .data-table tr:nth-child(even) {
            background-color: #f8fafc;
        }
        .data-table tr:hover {
            background-color: #ebf4ff;
        }
        .chart-container {
            height: 400px;
            margin-bottom: 20px;
            position: relative;
            padding: 20px;
            max-height: 450px;
            overflow-y: auto;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
        }
        
        .chart-wrapper {
            position: relative;
            margin-bottom: 40px;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            padding: 15px;
        }
        
        .sensor-type-header {
            margin: 30px 0 15px 0;
            padding: 10px 0;
            border-bottom: 2px solid #e2e8f0;
            color: #2c5282;
            font-size: 18px;
            font-weight: 600;
        }
        .result-area {
            margin-top: 20px;
        }
        .result-card {
            margin-bottom: 20px;
        }
        .no-data-message, .no-analysis-message, .no-chart-data-message {
            text-align: center;
            padding: 30px;
            color: #718096;
        }
        /* 添加历史记录相关样式 */
        .history-section {
            margin-top: 30px;
            padding-top: 15px;
            border-top: 1px solid #e2e8f0;
        }
        
        .history-header-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .history-title {
            margin: 0;
            font-size: 18px;
            color: #2d3748;
        }
        
        .history-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .history-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            background-color: #f8fafc;
            border-radius: 6px;
            border-left: 4px solid #4299e1;
        }
        
        .history-header {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .history-time {
            font-size: 14px;
            color: #4a5568;
        }
        
        .history-stats {
            font-size: 16px;
            font-weight: 500;
            color: #2d3748;
        }
        
        .history-stats.warning {
            color: #d69e2e;
        }
        
        .history-stats.critical {
            color: #e53e3e;
        }
        
        .history-actions {
            display: flex;
            gap: 8px;
        }
        
        .history-view-btn,
        .history-delete-btn {
            padding: 6px 10px;
            font-size: 13px;
            border-radius: 4px;
            border: none;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .history-view-btn {
            background-color: #4299e1;
            color: white;
        }
        
        .history-view-btn:hover {
            background-color: #3182ce;
        }
        
        .history-delete-btn {
            background-color: #e2e8f0;
            color: #4a5568;
        }
        
        .history-delete-btn:hover {
            background-color: #cbd5e0;
        }
        
        .no-history {
            padding: 12px;
            text-align: center;
            color: #718096;
            border: 1px dashed #cbd5e0;
            border-radius: 6px;
        }
        /* 异常值图表样式 */
        .anomaly-chart-container {
            height: 400px;
            margin-top: 20px;
            margin-bottom: 20px;
        }
        .no-anomalies-message {
            text-align: center;
            padding: 30px;
            color: #718096;
        }
        .anomaly-list {
            list-style-type: none;
            padding: 0;
        }
        .anomaly-item {
            background-color: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 10px 15px;
            margin-bottom: 10px;
            border-radius: 4px;
        }
        .anomaly-item.severe {
            background-color: #f8d7da;
            border-left-color: #dc3545;
        }
        .status-badge {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 12px;
            color: white;
            margin-right: 5px;
        }
        .status-normal {
            background-color: #28a745;
        }
        .status-warning {
            background-color: #ffc107;
            color: #212529;
        }
        .status-danger {
            background-color: #dc3545;
        }
        .tabs {
            display: flex;
            border-bottom: 1px solid #e2e8f0;
            margin-bottom: 24px;
            background-color: white;
            border-radius: 8px 8px 0 0;
            padding: 0 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }
        .tab {
            padding: 16px 20px;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            font-weight: 500;
            color: #4a5568;
            transition: all 0.2s;
            position: relative;
            display: flex;
            align-items: center;
        }
        .tab:hover {
            color: #2c5282;
        }
        .tab.active {
            border-bottom-color: #2c5282;
            color: #2c5282;
            font-weight: 600;
        }
        .tab.active::after {
            content: "";
            position: absolute;
            bottom: -3px;
            left: 50%;
            transform: translateX(-50%);
            width: 6px;
            height: 6px;
            background-color: #2c5282;
            border-radius: 50%;
        }
        .tab-content {
            display: none;
            background-color: white;
            border-radius: 0 0 8px 8px;
            padding: 15px;
            animation: fadeIn 0.3s ease-in-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .tab-content.active {
            display: block;
        }
        .loader {
            border: 5px solid #f3f3f3;
            border-top: 5px solid #007aff;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
            display: none;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .analysis-summary {
            background-color: #e8f4f8;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        .info-text {
            color: #6c757d;
            font-size: 14px;
            margin: 10px 0;
        }
        .anomaly-count {
            font-size: 24px;
            font-weight: bold;
            color: #dc3545;
            margin-right: 5px;
        }
        .no-data-message {
            text-align: center;
            padding: 30px;
            color: #6c757d;
        }
        .camera-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
        }
        .camera-item {
            width: calc(25% - 15px);
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            padding: 15px;
            margin-bottom: 5px;
            position: relative;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .camera-item:hover {
            transform: translateY(-3px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }
        .camera-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        .camera-name {
            font-size: 14px;
            font-weight: bold;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .camera-status {
            padding: 2px 6px;
            border-radius: 12px;
            font-size: 11px;
            white-space: nowrap;
        }
        .sensor-id {
            background-color: #f0f0f0;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 12px;
            margin-top: 4px;
            display: inline-block;
        }
        .online {
            background-color: #28a745;
            color: white;
        }
        .offline {
            background-color: #dc3545;
            color: white;
        }
        .warning {
            background-color: #ffc107;
            color: #212529;
        }
        .camera-view {
            position: relative;
            height: 160px;
            background-color: #f8f9fa;
            border-radius: 6px;
            overflow: hidden;
            margin-bottom: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #6c757d;
        }
        .camera-placeholder {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            width: 100%;
        }
        .camera-icon {
            font-size: 36px;
            margin-bottom: 10px;
            color: #6c757d;
        }
        .camera-message {
            font-size: 12px;
            text-align: center;
            padding: 0 10px;
        }
        .camera-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            border-radius: 6px;
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            transition: opacity 0.2s;
        }
        .camera-view:hover .camera-overlay {
            opacity: 1;
        }
        .camera-controls {
            display: flex;
            justify-content: space-between;
            margin-top: 8px;
        }
        .camera-control-btn {
            background-color: rgba(255,255,255,0.8);
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            margin: 0 2px;
            font-size: 12px;
        }
        .camera-control-btn:hover {
            background-color: rgba(255,255,255,1);
        }
        .camera-info {
            margin-top: 20px;
            padding: 10px 15px;
            background-color: #f8f9fa;
            border-radius: 8px;
        }
        .camera-alert {
            color: #007aff;
            font-size: 14px;
            margin-top: 10px;
        }
        .location-tag {
            font-size: 11px;
            color: #6c757d;
            margin-top: 4px;
            margin-bottom: 5px;
            display: block;
        }
        /* 列表视图样式 */
        .camera-list {
            display: none;
            flex-direction: column;
            gap: 10px;
        }
        .camera-list-item {
            display: flex;
            align-items: center;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            padding: 10px 15px;
        }
        .camera-list-icon {
            width: 40px;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-right: 15px;
            font-size: 24px;
        }
        .camera-list-info {
            flex-grow: 1;
        }
        .camera-list-actions {
            display: flex;
            gap: 10px;
        }
        .event-status-display {
            padding: 10px 0;
        }
        .event-status-header {
            display: flex;
            align-items: center;
            font-weight: 600;
            color: #2c5282;
            margin-bottom: 10px;
        }
        .event-details {
            background-color: #f8fafc;
            padding: 15px;
            border-radius: 8px;
            border-left: 3px solid #2c5282;
            transition: all 0.3s ease;
        }
        #currentEventName {
            font-weight: 600;
            font-size: 16px;
            margin-bottom: 5px;
        }
        #currentEventDescription {
            color: #4a5568;
            margin-bottom: 10px;
        }
        .event-progress-container {
            margin-top: 10px;
        }
        .event-progress-bar {
            height: 8px;
            background-color: #e2e8f0;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 5px;
        }
        .event-progress {
            height: 100%;
            background-color: #2c5282;
            border-radius: 4px;
            transition: width 0.3s ease;
        }
        .event-progress-text {
            text-align: right;
            font-size: 12px;
            color: #718096;
        }
        .event-alert {
            background-color: #fed7d7;
            border-left: 3px solid #e53e3e;
        }
        .event-alert #currentEventName {
            color: #c53030;
        }
        .event-alert .event-progress {
            background-color: #e53e3e;
        }
        .event-warning {
            background-color: #feebc8;
            border-left: 3px solid #dd6b20;
        }
        .event-warning #currentEventName {
            color: #c05621;
        }
        .event-warning .event-progress {
            background-color: #dd6b20;
        }
        .event-controls {
            margin: 15px 0;
            padding: 15px;
            background-color: #f8fafc;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .event-controls h3 {
            margin-top: 0;
            margin-bottom: 10px;
            color: #2d3748;
            font-size: 16px;
        }
        .event-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        .event-buttons button {
            padding: 6px 12px;
            background-color: #edf2f7;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .event-buttons button:hover {
            background-color: #e2e8f0;
        }
        .event-buttons button.active {
            background-color: #4299e1;
            color: white;
            border-color: #3182ce;
        }
        .chart-control-btn {
            transition: all 0.2s ease;
        }
        .chart-control-btn:hover {
            opacity: 0.9;
        }
        .chart-control-btn.active {
            background-color: #4299e1 !important;
            color: white !important;
            border-color: #3182ce !important;
        }
        
        /* 添加更紧凑的异常结果显示样式 */
        .analysis-container {
            display: block;
            margin-top: 15px;
        }
        
        .analysis-summary {
            width: 100%;
            margin-bottom: 20px;
        }
        
        .anomaly-chart-section {
            width: 100%;
            margin-bottom: 30px;
        }
        
        .anomaly-chart-container {
            height: 350px;
            margin-top: 10px;
            margin-bottom: 10px;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            background-color: #fff;
            padding: 10px;
        }
        
        .analysis-results-container {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #e2e8f0;
        }
        
        .analysis-col {
            flex: 1;
            min-width: 300px;
        }
        
        .anomaly-list-container {
            max-height: 500px;
            overflow-y: auto;
            padding-right: 5px;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            background-color: #fff;
        }
        
        .anomaly-filter-bar {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
            background-color: #f8fafc;
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
        }
        
        .filter-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .filter-label {
            font-size: 14px;
            color: #4a5568;
            white-space: nowrap;
        }
        
        .anomaly-item {
            background-color: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 10px 15px;
            margin-bottom: 8px;
            border-radius: 4px;
            transition: transform 0.2s;
        }
        
        .anomaly-item:hover {
            transform: translateX(5px);
        }
        
        .anomaly-item.severe {
            background-color: #f8d7da;
            border-left-color: #dc3545;
        }
        
        .anomaly-sensor-header {
            background-color: #edf2f7;
            padding: 10px 15px;
            border-radius: 4px;
            margin-top: 10px;
            margin-bottom: 5px;
        }
        
        .anomaly-sensor-header h5 {
            margin: 0;
            color: #2d3748;
            font-size: 15px;
        }
        
        .anomaly-info {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            font-size: 14px;
        }
        
        .anomaly-time {
            font-weight: 500;
            flex-basis: 100%;
        }
        
        .anomaly-value, .anomaly-score, .anomaly-type {
            flex: 1;
            min-width: 80px;
        }
        
        .anomaly-type {
            color: #2c5282;
            font-weight: 500;
        }
        
        .history-section {
            margin-top: 30px;
            padding-top: 15px;
            border-top: 1px solid #e2e8f0;
        }
        
        .history-header-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .history-title {
            margin: 0;
            font-size: 18px;
            color: #2d3748;
        }
        
        .history-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .history-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            background-color: #f8fafc;
            border-radius: 6px;
            border-left: 4px solid #4299e1;
        }
        
        .history-header {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .history-time {
            font-size: 14px;
            color: #4a5568;
        }
        
        .history-stats {
            font-size: 16px;
            font-weight: 500;
            color: #2d3748;
        }
        
        .history-stats.warning {
            color: #d69e2e;
        }
        
        .history-stats.critical {
            color: #e53e3e;
        }
        
        .history-actions {
            display: flex;
            gap: 8px;
        }
        
        .history-view-btn,
        .history-delete-btn {
            padding: 6px 10px;
            font-size: 13px;
            border-radius: 4px;
            border: none;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .history-view-btn {
            background-color: #4299e1;
            color: white;
        }
        
        .history-view-btn:hover {
            background-color: #3182ce;
        }
        
        .history-delete-btn {
            background-color: #e2e8f0;
            color: #4a5568;
        }
        
        .history-delete-btn:hover {
            background-color: #cbd5e0;
        }
        
        .no-history {
            padding: 12px;
            text-align: center;
            color: #718096;
            border: 1px dashed #cbd5e0;
            border-radius: 6px;
        }
        /* 传感器类型标记样式 */
        .sensor-type-tag {
            display: inline-block;
            font-size: 11px;
            padding: 2px 5px;
            border-radius: 3px;
            color: white;
            margin-top: 3px;
            font-weight: bold;
        }
        
        .type-温度 .sensor-type-tag {
            background-color: #e53e3e;
        }
        
        .type-应变 .sensor-type-tag {
            background-color: #3182ce;
        }
        
        .type-振动 .sensor-type-tag {
            background-color: #805ad5;
        }
        
        .type-倾角 .sensor-type-tag {
            background-color: #dd6b20;
        }
        
        /* 传感器ID检索样式 */
        #sensor-search {
            padding: 10px 12px;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            font-size: 14px;
            width: 250px;
            outline: none;
            transition: border-color 0.2s;
        }
        
        #sensor-search:focus {
            border-color: #4299e1;
            box-shadow: 0 0 0 2px rgba(66, 153, 225, 0.2);
        }
        
        #search-sensor-btn {
            margin-left: 8px;
            padding: 8px 12px;
            vertical-align: middle;
            display: inline-flex;
            align-items: center;
            background-color: #4299e1;
            color: white;
            border: none;
        }
        
        #search-sensor-btn:hover {
            background-color: #3182ce;
        }
        
        #search-sensor-btn .material-icons {
            font-size: 16px;
            margin-right: 4px;
        }
        
        .monitor-filter {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
        }
        
        #camera-filter {
            margin-left: 15px;
        }
        
        #search-result-message {
            animation: fadeIn 0.3s ease-in-out;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        /* 折叠标题样式 */
        .collapsible-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
        }
        
        .collapse-btn {
            background: none;
            border: none;
            color: #4a5568;
            cursor: pointer;
            padding: 5px;
            transition: transform 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .collapse-btn.collapsed .material-icons {
            transform: rotate(-90deg);
        }
        
        /* 隐藏和显示动画 */
        .collapsible-content {
            transition: max-height 0.3s ease-out;
            overflow: hidden;
        }
        
        /* 摄像头相关样式 */
        .camera-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .camera-item {
            background-color: #fff;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease;
        }
        
        .camera-item:hover {
            transform: translateY(-5px);
        }
        
        .camera-view {
            height: 180px;
            position: relative;
            background-color: #1a202c;
            overflow: hidden;
        }
        
        .camera-view.offline {
            background-color: #4a5568;
        }
        
        .camera-view.warning {
            background-color: #744210;
        }
        
        /* 摄像头视频流样式 */
        .camera-stream {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none; /* 初始隐藏 */
            justify-content: center;
            align-items: center;
            z-index: 1;
        }
        
        /* 加载动画 */
        .loading-message {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 14px;
            padding: 20px;
            text-align: center;
        }
        
        .spinner {
            width: 40px;
            height: 40px;
            margin-bottom: 10px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* 摄像头错误样式 */
        .camera-error {
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            text-align: center;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        
        .retry-btn {
            margin-top: 10px;
            background-color: #2b6cb0;
            border: none;
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .retry-btn:hover {
            background-color: #2c5282;
        }
        
        /* 视频警告覆盖层 */
        .video-warning-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(220, 53, 69, 0.2);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2;
            animation: pulse 2s infinite;
        }
        
        .warning-icon {
            background-color: rgba(220, 53, 69, 0.8);
            border-radius: 50%;
            width: 50px;
            height: 50px;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .warning-icon .material-icons {
            color: white;
            font-size: 30px;
        }
        
        .warning-text {
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-weight: bold;
        }
        
        @keyframes pulse {
            0% { opacity: 0.8; }
            50% { opacity: 0.4; }
            100% { opacity: 0.8; }
        }

        @keyframes pulse {
            0% { opacity: 0.8; }
            50% { opacity: 0.4; }
            100% { opacity: 0.8; }
        }
        
        /* 摄像头操作反馈样式 */
        .camera-feedback {
            position: absolute;
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 30px 8px 15px;
            border-radius: 4px;
            font-size: 13px;
            font-weight: 500;
            max-width: 280px;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            z-index: 100;
            animation: slide-up 0.3s ease-out;
            transition: opacity 0.3s ease;
        }
        
        .camera-feedback.success {
            border-left: 3px solid #38a169;
        }
        
        .camera-feedback.warning {
            border-left: 3px solid #f6ad55;
        }
        
        .camera-feedback.error {
            border-left: 3px solid #f56565;
        }
        
        .camera-feedback.fade-out {
            opacity: 0;
        }
        
        .feedback-close {
            position: absolute;
            top: 5px;
            right: 8px;
            font-size: 16px;
            cursor: pointer;
            opacity: 0.7;
        }
        
        .feedback-close:hover {
            opacity: 1;
        }
        
        @keyframes slide-up {
            from {
                transform: translate(-50%, 10px);
                opacity: 0;
            }
            to {
                transform: translate(-50%, 0);
                opacity: 1;
            }
        }
        /* 响应式调整 */
        @media (max-width: 768px) {
            .sidebar {
                width: 100%;
                height: auto;
                position: relative;
            }

            .sidebar-menu {
                flex-direction: row;
                justify-content: center;
                padding: 10px;
            }

            .content {
                margin-left: 0;
            }
        }

        .project-info-container {
            background-color: #f8f9fa;
            border-top: 1px solid #e2e8f0;
            padding: 20px;
            margin-top: 60px;
            text-align: center;
            font-size: 14px;
            color: #4a5568;
            clear: both;
            position: relative;
            z-index: 10;
            width: 100%;
            box-sizing: border-box;
        }

        .project-info {
            max-width: 1000px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .project-item {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        .project-item strong {
            color: #2c5282;
        }

        @media (max-width: 768px) {
            .project-item {
                flex-direction: column;
                align-items: center;
            }
        }
    </style>
</head>
<body>
    <!-- 登录模态框 -->
    <div id="loginModal" class="login-modal">
        <div class="login-container">
            <div class="login-header">
                <h2>基于多传感器时空协同学习的桥梁异常信息智能提取系统</h2>
                <p>请登录以继续访问</p>
            </div>
            <form id="loginForm" class="login-form">
                <div class="form-group">
                    <label for="username">用户名</label>
                    <input type="text" id="username" name="username" placeholder="请输入用户名" required>
                </div>
                <div class="form-group">
                    <label for="password">密码</label>
                    <input type="password" id="password" name="password" placeholder="请输入密码" required>
                </div>
                <button type="submit" class="login-button">登录</button>
                <div id="errorMessage" class="error-message"></div>
            </form>
        </div>
    </div>

    <div class="header">
        <h1>基于多传感器时空协同学习的桥梁异常信息智能提取系统</h1>
        <div class="header-subtitle">基于数据驱动的桥梁结构安全实时监测平台</div>
        <div class="user-info">
            <div class="user-avatar" id="userAvatar">管</div>
            <span id="userDisplay">监测员：管理员</span>
            <button id="logoutBtn" class="logout-btn">登出</button>
        </div>
    </div>

    <div class="container">
        <div class="card">
            <div class="card-title">数据上传与分析</div>
            <div class="upload-area">
                <div class="file-input-container">
                    <div class="custom-file-input">
                        <span class="material-icons">cloud_upload</span>
                        选择文件
                    </div>
                    <input type="file" id="fileInput" accept=".txt,.csv">
                </div>
                <button class="button" id="uploadButton">
                    <span class="material-icons">publish</span>
                    上传数据
                </button>
                <button class="button secondary" id="resetButton">
                    <span class="material-icons">restart_alt</span>
                    重置
                </button>
                <button class="button" id="detectButton" disabled>
                    <span class="material-icons">search</span>
                    开始检测
                </button>
                <button class="button secondary" id="sampleButton">
                    <span class="material-icons">data_object</span>
                    生成示例数据
                </button>
                <button class="button secondary" id="refreshButton">
                    <span class="material-icons">autorenew</span>
                    随机刷新数据
                </button>
            </div>
            <div class="info-text" id="fileInfo">未选择文件</div>
            <a href="#" id="downloadExample" class="example-file-link">
                <span class="material-icons" style="font-size:16px;vertical-align:middle;">file_download</span> 
                下载数据格式示例文件
            </a>
            <div class="file-format-info">
                <strong>支持的文件格式:</strong>
                <ul style="margin-top: 5px; margin-bottom: 5px;">
                    <li>CSV格式: 时间戳,传感器ID,数值 (每行一条记录)</li>
                    <li>TXT格式: 时间戳,数值 (每行一条记录，自动分配传感器ID)</li>
                </ul>
                <div>示例: 2023-06-15 14:30,传感器A,23.45</div>
            </div>
        </div>

        <div class="tabs">
            <div class="tab active" data-tab="data">
                <span class="material-icons" style="margin-right:8px;">table_chart</span>
                数据查看
            </div>
            <div class="tab" data-tab="visualization">
                <span class="material-icons" style="margin-right:8px;">bar_chart</span>
                数据可视化
            </div>
            <div class="tab" data-tab="analysis">
                <span class="material-icons" style="margin-right:8px;">analytics</span>
                异常检测结果
            </div>
            <div class="tab" data-tab="repair">
                <span class="material-icons" style="margin-right:8px;">healing</span>
                数据修复
            </div>
            <div class="tab" data-tab="monitor">
                <span class="material-icons" style="margin-right:8px;">videocam</span>
                异常监控
            </div>
        </div>

        <div class="tab-content active" id="data-tab">
            <div class="card">
                <div class="card-title">传感器数据</div>
                <div class="data-table-container">
                    <table class="data-table" id="dataTable">
                        <thead>
                            <tr>
                                <th>时间戳</th>
                                <th>传感器ID</th>
                                <th>数值</th>
                                <th>状态</th>
                            </tr>
                        </thead>
                        <tbody>
                            <!-- 数据行将动态插入 -->
                        </tbody>
                    </table>
                </div>
                <div class="no-data-message" id="noDataMessage">
                    请上传数据文件开始分析
                </div>
            </div>
        </div>

        <div class="tab-content" id="visualization-tab">
            <div class="card">
                <div class="card-title">传感器数据可视化</div>
                <div class="chart-container" id="chart-container" style="max-height: 500px; overflow-y: auto; margin-bottom: 30px;">
                    <!-- 按传感器类型分组的图表将在这里创建 -->
                </div>
                <div class="no-data-message" id="noChartDataMessage">
                    请上传数据文件查看可视化图表
                </div>
            </div>
        </div>

        <div class="tab-content" id="analysis-tab">
            <div class="card">
                <div class="card-title">异常检测分析</div>
                <div id="no-analysis-message" class="no-analysis-message">
                    <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 30px;">
                        <span class="material-icons" style="font-size: 48px; color: #cbd5e0; margin-bottom: 15px;">search</span>
                        <p>等待异常检测</p>
                        <p style="font-size: 14px; color: #718096;">请上传传感器数据并点击"开始检测"按钮</p>
                    </div>
                </div>
                <div id="analysis-loader" style="display: none; text-align: center; padding: 30px;">
                    <div class="spinner"></div>
                    <p style="margin-top: 15px;">正在进行异常检测，请稍候...</p>
                </div>
                
                <div id="analysis-content" style="display: none;">
                    <div id="analysis-summary"></div>
                    
                    <div class="analysis-container">
                        <div id="anomaly-chart-section" class="anomaly-chart-section" style="display: none;">
                            <div class="section-title collapsible-header">
                                异常点分布图表
                                <button id="toggle-anomaly-charts" class="collapse-btn">
                                    <span class="material-icons">expand_more</span>
                                </button>
                            </div>
                            <div class="anomaly-chart-container" id="anomaly-chart-container" style="max-height: 350px; overflow-y: auto;">
                                <!-- 按传感器类型分组的异常检测图表将在这里创建 -->
                            </div>
                        </div>
                        
                        <div class="analysis-results-container">
                            <div class="analysis-col">
                                <div class="section-title">异常点列表</div>
                                <div class="anomaly-filter-bar">
                                    <div class="filter-group">
                                        <span class="filter-label">异常类型:</span>
                                        <select id="anomaly-type-filter" class="form-select form-select-sm">
                                            <option value="all">全部</option>
                                            <option value="单点异常">单点异常</option>
                                            <option value="连续性异常">连续性异常</option>
                                            <option value="群体异常">群体异常</option>
                                        </select>
                                    </div>
                                    <button onclick="startAnomalyDetection()" class="button" style="margin-left: auto; padding: 5px 10px; font-size: 14px;">
                                        <span class="material-icons" style="font-size: 16px;">refresh</span> 重新检测
                                    </button>
                                </div>
                                <div class="anomaly-list-container">
                                    <div id="anomaly-list" class="anomaly-list"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- 历史记录部分已移除 -->
                </div>
            </div>
        </div>

        <div class="tab-content" id="repair-tab">
            <div class="card">
                <div class="card-title">传感器数据修复</div>
                <div id="no-repair-message" class="no-repair-message">
                    <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 30px;">
                        <span class="material-icons" style="font-size: 48px; color: #cbd5e0; margin-bottom: 15px;">healing</span>
                        <p>等待数据修复</p>
                        <p style="font-size: 14px; color: #718096;">请先检测异常数据，然后选择需要修复的传感器</p>
                    </div>
                </div>
                
                <div id="repair-control" class="repair-control" style="padding: 20px; background-color: #f8fafc; border-radius: 8px; margin-bottom: 20px; display: none;">
                    <div style="display: flex; flex-wrap: wrap; gap: 15px; align-items: center;">
                        <div style="flex: 1; min-width: 250px;">
                            <label for="repair-sensor-select" style="display: block; margin-bottom: 8px; font-weight: 500;">选择异常传感器:</label>
                            <select id="repair-sensor-select" class="form-select" style="width: 100%; padding: 8px; border-radius: 4px; border: 1px solid #e2e8f0;">
                                <option value="">-- 请选择传感器 --</option>
                            </select>
                        </div>
                        <div style="flex: 1; min-width: 250px;">
                            <label for="repair-model-select" style="display: block; margin-bottom: 8px; font-weight: 500;">修复模型:</label>
                            <select id="repair-model-select" class="form-select" style="width: 100%; padding: 8px; border-radius: 4px; border: 1px solid #e2e8f0;">
                                <option value="lstm">LSTM预测修复</option>
                            </select>
                        </div>
                        <div style="flex: 0 0 auto; align-self: flex-end;">
                            <button id="start-repair-btn" class="button" style="margin-top: 8px;">
                                <span class="material-icons" style="margin-right: 4px; font-size: 16px;">healing</span>
                                开始修复
                                </button>
                            </div>
                        </div>
                    </div>
                
                <div id="repair-loader" style="display: none; text-align: center; padding: 30px;">
                    <div class="spinner"></div>
                    <p style="margin-top: 15px;">正在进行数据修复，请稍候...</p>
                </div>
                
                <div id="repair-content" style="display: none;">
                    <div id="repair-summary" class="alert-compact alert-info" style="margin-bottom: 20px;">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <h5 style="margin: 0; font-size: 16px;">数据修复完成</h5>
                            <span style="font-size: 14px;" id="repair-timestamp"></span>
                        </div>
                        <div id="repair-stats" style="margin-top: 10px;"></div>
                    </div>
                    
                    <div class="repair-container">
                        <div class="chart-container" style="max-height: 350px; overflow-y: auto; margin-bottom: 20px;">
                            <canvas id="repair-chart"></canvas>
                        </div>
                        
                        <div class="data-table-container">
                            <table class="data-table" id="repair-table">
                                <thead>
                                    <tr>
                                        <th>时间戳</th>
                                        <th>传感器ID</th>
                                        <th>原始值</th>
                                        <th>修复值</th>
                                        <th>状态</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <!-- 修复数据将动态插入 -->
                                </tbody>
                            </table>
                        </div>
                        
                        <div style="margin-top: 20px; display: flex; gap: 10px; justify-content: flex-end;">
                            <button id="apply-repair-btn" class="button">
                                <span class="material-icons" style="margin-right: 4px; font-size: 16px;">check</span>
                                应用修复
                            </button>
                            <button id="export-repair-btn" class="button secondary">
                                <span class="material-icons" style="margin-right: 4px; font-size: 16px;">file_download</span>
                                导出数据
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="tab-content" id="monitor-tab">
            <div class="card">
                <div class="card-title">异常位置摄像头监控</div>
                <div class="monitor-controls">
                    <div class="monitor-filter">
                        <input type="text" id="sensor-search" placeholder="输入传感器ID进行检索..." aria-label="传感器ID检索">
                        <button class="button secondary" id="search-sensor-btn">
                            <span class="material-icons">search</span>
                            检索
                        </button>
                        <select id="camera-filter" aria-label="摄像头筛选">
                            <option value="all">所有摄像头</option>
                            <option value="online">仅在线</option>
                            <option value="offline">仅离线</option>
                            <option value="warning">仅异常</option>
                        </select>
                    </div>
                </div>
                <div class="camera-grid" id="camera-container">
                    <!-- 摄像头将通过 JavaScript 动态生成 -->
                </div>
                <div class="camera-info">
                    <div class="info-text">点击摄像头图标<span class="material-icons" style="font-size:14px;vertical-align:middle;">videocam</span>可查看实时画面</div>
                    <div class="camera-alert" id="cameraAlert">
                        <strong>系统状态:</strong> <span id="system-status">监控系统运行正常</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- 添加异常值图表区域 -->
        <div id="anomaly-chart-section" style="display: none;">
            <div class="card">
                <div class="card-title">
                    <span class="material-icons" style="margin-right: 8px;">timeline</span>
                    异常值图表
                </div>
                <div id="anomaly-chart-container2" class="anomaly-chart-container" style="max-height: 350px; overflow-y: auto;">
                    <div class="no-anomalies-message">
                        异常检测完成后将在此处显示图表
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // 全局变量
        let sensorData = [];
        let anomalies = [];
        let dataChart = null;
        let anomalyChart = null;
        let isLoggedIn = true; // 默认为已登录状态
        let currentUser = { username: "系统用户" }; // 默认用户信息

        // DOM元素
        const fileInput = document.getElementById('fileInput') || { addEventListener: () => {} };
        const fileInfo = document.getElementById('fileInfo') || { textContent: '' };
        const uploadButton = document.getElementById('uploadButton') || { disabled: true };
        const resetButton = document.getElementById('resetButton') || { addEventListener: () => {} };
        const detectButton = document.getElementById('detectButton') || { disabled: true };
        const dataTable = document.getElementById('dataTable') || { getElementsByTagName: () => [{ innerHTML: '' }] };
        const noDataMessage = document.getElementById('noDataMessage') || { style: { display: 'none' } };
        const noChartDataMessage = document.getElementById('noChartDataMessage') || { style: { display: 'none' } };
        const noAnalysisMessage = document.getElementById('noAnalysisMessage') || { style: { display: 'none' } };
        const analysisLoader = document.getElementById('analysisLoader') || { style: { display: 'none' } };
        const analysisSummary = document.getElementById('analysisSummary') || { style: { display: 'none' } };
        const anomalyList = document.getElementById('anomalyList') || { innerHTML: '' };
        const sampleDataButton = document.getElementById('sample-data-button') || document.getElementById('sampleButton') || { addEventListener: () => {} };
        const cameraContainer = document.getElementById('camera-container') || { innerHTML: '' };
        
        // 创建一个全局的数据变量（如果尚未定义）
        window.sensorData = window.sensorData || [];
        window.dataChart = window.dataChart || null;
        window.dataUpdateInterval = window.dataUpdateInterval || null;
        
        // 初始化系统
        function initSystem() {
            try {
                // 初始化必要组件
                initEventListeners();
                
                // 创建样本数据按钮事件监听
                const sampleBtn = document.getElementById('sample-data-button') || document.getElementById('sampleButton');
                if (sampleBtn) {
                    sampleBtn.addEventListener('click', function() {
                        createSampleData();
                        // 确保检测按钮启用
                        if (detectButton) detectButton.disabled = false;
                    });
                } else {
                    console.warn("未找到示例数据按钮");
                }
                
                // 随机刷新数据按钮事件监听
                const refreshBtn = document.getElementById('refreshButton');
                if (refreshBtn) {
                    refreshBtn.addEventListener('click', function() {
                        if (typeof refreshData === 'function') {
                            refreshData();
                        } else {
                            console.warn("刷新数据函数未定义");
                        }
                    });
                }
                
                // 传感器ID检索功能
                const sensorSearchBtn = document.getElementById('search-sensor-btn');
                const sensorSearchInput = document.getElementById('sensor-search');
                
                if (sensorSearchBtn && sensorSearchInput) {
                    sensorSearchBtn.addEventListener('click', function() {
                        const searchTerm = sensorSearchInput.value.trim();
                        searchSensorById(searchTerm);
                    });
                    
                    // 支持回车键搜索
                    sensorSearchInput.addEventListener('keypress', function(e) {
                        if (e.key === 'Enter') {
                            const searchTerm = sensorSearchInput.value.trim();
                            searchSensorById(searchTerm);
                        }
                    });
                }
            } catch (error) {
                console.error("初始化系统时出错:", error);
            }
        }
        
        // 刷新数据的包装函数
        function refreshData() {
            if (window.dataUpdateInterval) {
                stopDataUpdates();
            } else {
                startRandomDataUpdates();
            }
        }
        
        // 根据传感器ID搜索相关摄像头
        function searchSensorById(sensorId) {
            console.log(`搜索传感器ID: ${sensorId}`);
            if (!sensorId) {
                // 如果搜索词为空，恢复显示所有摄像头
                initCameraMonitor();
                return;
            }
            
            // 在实际系统中，这里会根据传感器ID过滤相关的摄像头
            // 这里只做演示，假设传感器ID与摄像头区域有以下映射关系
            let matchedCameras = [];
            
            // 如果包含位置关键词，则匹配相应区域摄像头
            if (sensorId.includes('北段')) {
                matchedCameras = [1, 2, 3]; // 北段摄像头编号
            } else if (sensorId.includes('中段')) {
                matchedCameras = [4, 5, 6]; // 中段摄像头编号
            } else if (sensorId.includes('南段')) {
                matchedCameras = [7, 8, 9]; // 南段摄像头编号
            } else {
                // 如果没有匹配的位置，尝试直接匹配传感器类型
                if (sensorId.includes('温度')) {
                    matchedCameras = [1, 4, 7]; // 温度传感器相关摄像头
                } else if (sensorId.includes('应变')) {
                    matchedCameras = [2, 5, 8]; // 应变传感器相关摄像头
                } else if (sensorId.includes('振动')) {
                    matchedCameras = [3, 6, 9]; // 振动传感器相关摄像头
                } else if (sensorId.includes('倾角')) {
                    matchedCameras = [1, 5, 9]; // 倾角传感器相关摄像头
                }
            }
            
            // 过滤相机显示
            const allCameras = document.querySelectorAll('.camera-item');
            let foundMatches = false;
            
            allCameras.forEach(camera => {
                const cameraId = parseInt(camera.dataset.cameraId);
                if (matchedCameras.includes(cameraId)) {
                    camera.style.display = 'block';
                    foundMatches = true;
                } else {
                    camera.style.display = 'none';
                }
            });
            
            // 显示搜索结果信息
            const container = document.getElementById('camera-container');
            
            // 先移除之前的提示消息（如果有）
            const prevMessage = document.getElementById('search-result-message');
            if (prevMessage) {
                prevMessage.remove();
            }
            
            // 添加搜索结果提示
            const resultMessage = document.createElement('div');
            resultMessage.id = 'search-result-message';
            resultMessage.style.padding = '15px';
            resultMessage.style.margin = '10px 0';
            resultMessage.style.backgroundColor = '#f8f9fa';
            resultMessage.style.borderRadius = '4px';
            resultMessage.style.border = '1px solid #e9ecef';
            
            if (foundMatches) {
                resultMessage.innerHTML = `<strong>搜索结果:</strong> 找到 ${matchedCameras.length} 个与传感器 "${sensorId}" 相关的监控位置`;
            } else {
                resultMessage.innerHTML = `<strong>搜索结果:</strong> 未找到与传感器 "${sensorId}" 相关的监控位置`;
            }
            
            // 插入到容器的最前面
            if (container.firstChild) {
                container.insertBefore(resultMessage, container.firstChild);
            } else {
                container.appendChild(resultMessage);
            }
        }

        // 初始化事件监听
        function initEventListeners() {
            try {
                // 文件上传事件
                if (fileInput) {
                    fileInput.addEventListener('change', function() {
                        if (this.files.length > 0) {
                            const file = this.files[0];
                            if (fileInfo) fileInfo.textContent = `已选择文件: ${file.name} (${formatFileSize(file.size)})`;
                            if (uploadButton) uploadButton.disabled = false;
                        } else {
                            if (fileInfo) fileInfo.textContent = '未选择文件';
                            if (uploadButton) uploadButton.disabled = true;
                        }
                    });
                }

                // 上传按钮事件
                if (uploadButton) {
                    uploadButton.addEventListener('click', function() {
                        if (!fileInput) return;
                        const file = fileInput.files[0];
                        if (file) {
                            const reader = new FileReader();
                            reader.onload = function(e) {
                                try {
                                    const content = e.target.result;
                                    processData(content);
                                    
                                    // 确保数据处理后启用检测按钮
                                    if (window.sensorData.length > 0) {
                                        console.log("成功加载数据点：", window.sensorData.length);
                                        if (detectButton) detectButton.disabled = false;
                                    } else {
                                        console.warn("数据处理完成，但没有有效数据点");
                                        alert('未能从文件中提取有效数据，请检查文件格式');
                                        if (detectButton) detectButton.disabled = true;
                                    }
                                } catch (error) {
                                    console.error('数据解析错误:', error);
                                    alert('数据解析错误: ' + error.message);
                                }
                            };
                            reader.onerror = function(e) {
                                console.error('文件读取错误:', e);
                                alert('文件读取错误!');
                            };
                            reader.readAsText(file);
                        } else {
                            alert('请先选择一个文件!');
                        }
                    });
                }

                // 检测按钮事件
                if (detectButton) {
                    detectButton.addEventListener('click', function() {
                        console.log("点击检测按钮，当前数据点数量:", window.sensorData.length);
                        if (window.sensorData && window.sensorData.length > 0) {
                            console.log("开始异常检测...");
                            startAnomalyDetection();
                        } else {
                            console.warn("没有数据可供检测");
                            alert('请先上传数据!');
                        }
                    });
                }
            } catch (error) {
                console.error('初始化事件监听器时出错:', error);
            }
        }

        // 页面加载完成后执行初始化
        document.addEventListener('DOMContentLoaded', function() {
            try {
                // 初始化系统
                initSystem();
                
                // 确保重置按钮可用
                if (resetButton) {
                    resetButton.addEventListener('click', resetAll);
                } else {
                    console.warn('未找到重置按钮');
                }
            } catch (error) {
                console.error('初始化过程中出错:', error);
            }
        });

        // 初始化桥梁监控图
        function initBridgeMonitor() {
            const bridge = document.querySelector('.bridge');
            
            if (!sensorData || sensorData.length === 0) {
                return;
            }
            
            // 清除现有传感器点
            document.querySelectorAll('.sensor-point').forEach(point => point.remove());
            
            // 创建传感器点
            const uniqueSensors = [...new Set(sensorData.map(item => item.sensorId))];
            
            uniqueSensors.forEach((sensorId, index) => {
                // 获取该传感器的所有数据点
                const sensorPoints = sensorData.filter(item => item.sensorId === sensorId);
                
                // 判断传感器状态
                let status = 'normal';
                for (const point of sensorPoints) {
                    if (point.status === 'danger') {
                        status = 'danger';
                        break;
                    } else if (point.status === 'warning') {
                        status = 'warning';
                    }
                }
                
                // 计算位置（均匀分布在桥面上）
                const xPos = 10 + (80 * index / (uniqueSensors.length > 1 ? uniqueSensors.length - 1 : 1)) + '%';
                const yPos = '120px'; // 放在桥面上
                
                // 创建传感器点元素
                const sensorPoint = document.createElement('div');
                sensorPoint.className = `sensor-point ${status}`;
                sensorPoint.style.left = xPos;
                sensorPoint.style.top = yPos;
                sensorPoint.dataset.sensorId = sensorId;
                sensorPoint.dataset.status = status;
                
                // 添加悬停事件显示工具提示
                sensorPoint.addEventListener('mouseover', function(e) {
                    const rect = this.getBoundingClientRect();
                    
                    // 统计异常数量
                    const abnormalCount = sensorPoints.filter(p => p.status === 'danger').length;
                    
                    sensorTooltip.innerHTML = `
                        <strong>传感器:</strong> ${sensorId}<br>
                        <strong>状态:</strong> ${getStatusText(status)}<br>
                        <strong>异常点数:</strong> ${abnormalCount}
                    `;
                    
                    sensorTooltip.style.top = `${rect.top - 70}px`;
                    sensorTooltip.style.left = `${rect.left}px`;
                    sensorTooltip.style.opacity = '1';
                });
                
                sensorPoint.addEventListener('mouseout', function() {
                    sensorTooltip.style.opacity = '0';
                });
                
                // 点击跳转到对应传感器的分析结果
                sensorPoint.addEventListener('click', function() {
                    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                    document.querySelector('.tab[data-tab="analysis"]').classList.add('active');
                    
                    document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
                    document.getElementById('analysis-tab').classList.add('active');
                    
                    // 滚动到异常列表位置
                    document.querySelector('.result-area').scrollIntoView({ behavior: 'smooth' });
                    
                    // 高亮显示对应传感器的异常
                    document.querySelectorAll('.anomaly-item').forEach(item => {
                        if (item.textContent.includes(sensorId)) {
                            item.style.backgroundColor = '#fff3cd';
                            setTimeout(() => {
                                item.style.backgroundColor = '';
                            }, 2000);
                        }
                    });
                });
                
                bridge.appendChild(sensorPoint);
            });
        }

        function getStatusText(status) {
            switch(status) {
                case 'normal':
                    return '正常';
                case 'warning':
                    return '警告';
                case 'danger':
                    return '异常';
                default:
                    return '未知';
            }
        }

        // 初始化摄像头监控系统
        function initCameraMonitor() {
            try {
                console.log("初始化摄像头监控系统");
                
                // 查找摄像头容器
                const cameraContainerElement = document.getElementById('camera-container');
                if (!cameraContainerElement) {
                    console.error("未找到摄像头容器元素");
                    return;
                }
                
                // 清空摄像头容器
                cameraContainerElement.innerHTML = '';
                
                // 定义摄像头位置和对应的传感器
                const cameraLocations = [
                    { id: 1, name: "桥梁北端-左侧", status: "online", sensorId: "TL-101" },
                    { id: 2, name: "桥梁北端-右侧", status: "online", sensorId: "TR-102" },
                    { id: 3, name: "桥梁主跨-A1", status: "online", sensorId: "MA-201" },
                    { id: 4, name: "桥梁主跨-A2", status: "online", sensorId: "MA-202" },
                    { id: 5, name: "桥梁主跨-B1", status: "warning", sensorId: "MB-203" },
                    { id: 6, name: "桥梁主跨-B2", status: "online", sensorId: "MB-204" },
                    { id: 7, name: "桥梁主跨-C1", status: "offline", sensorId: "MC-205" },
                    { id: 8, name: "桥梁主跨-C2", status: "online", sensorId: "MC-206" },
                    { id: 9, name: "桥梁南端-左侧", status: "online", sensorId: "BL-301" },
                    { id: 10, name: "桥梁南端-右侧", status: "warning", sensorId: "BR-302" },
                ];
                
                // 创建摄像头视图
                cameraLocations.forEach(camera => {
                    const cameraItem = document.createElement('div');
                    cameraItem.className = 'camera-item';
                    cameraItem.dataset.cameraId = camera.id;
                    
                    const cameraView = document.createElement('div');
                    cameraView.className = 'camera-view';
                    
                    // 根据状态设置样式
                    if (camera.status === 'offline') {
                        cameraView.classList.add('offline');
                    } else if (camera.status === 'warning') {
                        cameraView.classList.add('warning');
                    }
                    
                    // 添加摄像头占位符
                    const placeholder = document.createElement('div');
                    placeholder.className = 'camera-placeholder';
                    
                    // 摄像头图标
                    const icon = document.createElement('div');
                    icon.className = 'camera-icon';
                    icon.innerHTML = camera.status !== 'offline' ? '<i class="fas fa-video"></i>' : '<i class="fas fa-video-slash"></i>';
                    placeholder.appendChild(icon);
                    
                    // 摄像头信息
                    const info = document.createElement('div');
                    info.className = 'camera-message';
                    info.textContent = camera.name + (camera.status === 'offline' ? ' (离线)' : '');
                    placeholder.appendChild(info);
                    
                    cameraView.appendChild(placeholder);
                    
                    // 添加摄像头覆盖层
                    const overlay = document.createElement('div');
                    overlay.className = 'camera-overlay';
                    
                    const controlBtn = document.createElement('button');
                    controlBtn.className = 'btn btn-sm btn-light';
                    controlBtn.innerHTML = '<i class="fas fa-expand"></i>';
                    controlBtn.addEventListener('click', function() {
                        showCameraFeedback(camera.id, `正在连接 ${camera.name} 摄像头...`);
                    });
                    
                    overlay.appendChild(controlBtn);
                    cameraView.appendChild(overlay);
                    
                    cameraItem.appendChild(cameraView);
                    
                    // 摄像头控制
                    const controls = document.createElement('div');
                    controls.className = 'camera-controls';
                    
                    const viewBtn = document.createElement('button');
                    viewBtn.className = 'camera-control-btn';
                    viewBtn.innerHTML = '<i class="fas fa-eye"></i>';
                    viewBtn.addEventListener('click', function() {
                        showCameraFeedback(camera.id, '查看直播流');
                    });
                    controls.appendChild(viewBtn);
                    
                    const recordBtn = document.createElement('button');
                    recordBtn.className = 'camera-control-btn';
                    recordBtn.innerHTML = '<i class="fas fa-circle"></i>';
                    recordBtn.addEventListener('click', function() {
                        showCameraFeedback(camera.id, '录制已开始');
                    });
                    controls.appendChild(recordBtn);
                    
                    const snapshotBtn = document.createElement('button');
                    snapshotBtn.className = 'camera-control-btn';
                    snapshotBtn.innerHTML = '<i class="fas fa-camera"></i>';
                    snapshotBtn.addEventListener('click', function() {
                        showCameraFeedback(camera.id, '已保存快照');
                    });
                    controls.appendChild(snapshotBtn);
                    
                    cameraItem.appendChild(controls);
                    
                    // 添加到摄像头容器
                    cameraContainerElement.appendChild(cameraItem);
                });
                
                // 隐藏无监控消息
                if (noMonitorMessage) {
                    noMonitorMessage.style.display = 'none';
                }
            } catch (error) {
                console.error("初始化摄像头监控时出错:", error);
            }
        }

        // 筛选摄像头
        function filterCameras() {
            const filterValue = document.getElementById('camera-filter').value;
            const searchText = document.getElementById('camera-search').value.toLowerCase();
            
            const cameraItems = document.querySelectorAll('.camera-item');
            
            cameraItems.forEach(item => {
                const cameraStatus = item.dataset.status;
                const cameraId = item.dataset.cameraId;
                const cameraName = item.querySelector('.camera-name').textContent.toLowerCase();
                const locationName = item.querySelector('.location-tag').textContent.toLowerCase();
                const sensorId = item.dataset.sensorId.toLowerCase();
                
                let statusMatch = true;
                if (filterValue !== 'all') {
                    statusMatch = cameraStatus === filterValue;
                }
                
                const searchMatch = 
                    cameraName.includes(searchText) || 
                    locationName.includes(searchText) || 
                    sensorId.includes(searchText) ||
                    `摄像头 ${cameraId}`.toLowerCase().includes(searchText);
                
                if (statusMatch && searchMatch) {
                    item.style.display = '';
                } else {
                    item.style.display = 'none';
                }
            });
            
            // 更新无结果消息
            let visibleCount = 0;
            cameraItems.forEach(item => {
                if (item.style.display !== 'none') {
                    visibleCount++;
                }
            });
            
            if (visibleCount === 0) {
                // 如果没有匹配项，显示消息
                let noResultMessage = document.getElementById('no-camera-results');
                if (!noResultMessage) {
                    noResultMessage = document.createElement('div');
                    noResultMessage.id = 'no-camera-results';
                    noResultMessage.className = 'no-data-message';
                    noResultMessage.textContent = '没有匹配的摄像头';
                    cameraContainer.appendChild(noResultMessage);
                } else {
                    noResultMessage.style.display = 'block';
                }
            } else {
                // 隐藏消息（如果存在）
                const noResultMessage = document.getElementById('no-camera-results');
                if (noResultMessage) {
                    noResultMessage.style.display = 'none';
                }
            }
        }

        // 查看摄像头画面
        function viewCamera(cameraId) {
            try {
            console.log(`查看摄像头 #${cameraId} 画面`);
            
                // 查找摄像头元素
                const cameraItem = document.querySelector(`.camera-item[data-camera-id="${cameraId}"]`);
                if (!cameraItem) {
                    console.error(`未找到摄像头 #${cameraId} 的元素`);
                    return;
                }
                
                // 获取摄像头状态
                const cameraStatus = cameraItem.dataset.status;
                if (cameraStatus === 'offline') {
                    showActionFeedback(cameraId, `摄像头 #${cameraId} 当前离线，无法连接`);
                    return;
                }
                
                // 查找摄像头视图和流容器
                const cameraView = cameraItem.querySelector('.camera-view');
                const placeholder = cameraItem.querySelector('.camera-placeholder');
                const streamContainer = cameraItem.querySelector('.camera-stream');
                
                if (!cameraView || !placeholder || !streamContainer) {
                    console.error(`摄像头 #${cameraId} 元素结构不完整`);
                    return;
                }
                
                // 显示加载消息
                const loadingMessage = document.createElement('div');
                loadingMessage.className = 'loading-message';
                loadingMessage.innerHTML = `
                    <div class="spinner"></div>
                    <div>连接摄像头中...</div>
                `;
                streamContainer.innerHTML = '';
                streamContainer.appendChild(loadingMessage);
                streamContainer.style.display = 'flex';
                placeholder.style.display = 'none';
                
                // 获取摄像头流URL
                const streamUrl = cameraItem.dataset.streamUrl;
                if (!streamUrl) {
                    showActionFeedback(cameraId, `摄像头 #${cameraId} 未配置视频流地址`);
                    streamContainer.innerHTML = '<div class="camera-error">未配置视频流地址</div>';
                    return;
                }
                
                // 创建视频元素
                const videoElement = document.createElement('video');
                videoElement.id = `video-stream-${cameraId}`;
                videoElement.autoplay = true;
                videoElement.playsInline = true;
                videoElement.muted = true;
                videoElement.style.width = '100%';
                videoElement.style.height = '100%';
                videoElement.style.objectFit = 'cover';
                
                // 连接到摄像头流
                connectToCameraStream(cameraId, streamUrl, videoElement)
                    .then(() => {
                        // 连接成功，替换加载消息
                        streamContainer.innerHTML = '';
                        streamContainer.appendChild(videoElement);
                        showActionFeedback(cameraId, `摄像头 #${cameraId} 直播已连接`);
                        
                        // 检查相关传感器是否存在异常
                        const sensorId = cameraItem.dataset.sensorId;
                        if (sensorId && window.sensorData) {
                            const sensorData = window.sensorData.filter(data => data.sensorId === sensorId);
                            const hasAbnormalData = sensorData.some(data => data.status === 'danger' || data.status === 'warning');
                            
                            if (hasAbnormalData) {
                                // 在视频上添加警告覆盖层
                                const warningOverlay = document.createElement('div');
                                warningOverlay.className = 'video-warning-overlay';
                                warningOverlay.innerHTML = `
                                    <div class="warning-icon">
                                        <span class="material-icons">warning</span>
                                    </div>
                                    <div class="warning-text">检测到传感器异常</div>
                                `;
                                streamContainer.appendChild(warningOverlay);
                            }
                        }
                    })
                    .catch(error => {
                        // 连接失败，显示错误消息
                        console.error(`连接摄像头 #${cameraId} 失败:`, error);
                        streamContainer.innerHTML = `
                            <div class="camera-error">
                                连接摄像头失败: ${error.message || '无法连接到视频流'}
                                <button class="retry-btn" onclick="viewCamera(${cameraId})">
                                    <span class="material-icons">refresh</span> 重试
                                </button>
                            </div>
                        `;
                        showActionFeedback(cameraId, `摄像头 #${cameraId} 连接失败`);
                    });
                
            } catch (error) {
                console.error(`查看摄像头 #${cameraId} 时出错:`, error);
                showActionFeedback(cameraId, `摄像头操作错误: ${error.message}`);
            }
        }
        
        // 连接到摄像头视频流
        async function connectToCameraStream(cameraId, streamUrl, videoElement) {
            return new Promise((resolve, reject) => {
                try {
                    console.log(`连接到摄像头 #${cameraId} 流: ${streamUrl}`);
                    
                    // 在实际应用中，这里需要根据后端API进行实现
                    // 以下是一个模拟连接的示例
                    
                    // 模拟摄像头连接延迟
                setTimeout(() => {
                        // 检查是否正在运行测试环境
                        if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
                            // 本地测试环境 - 使用模拟视频
                            console.log(`本地测试环境 - 使用模拟视频代替流 ${streamUrl}`);
                            
                            // 创建一个canvas元素来模拟视频流
                            const canvas = document.createElement('canvas');
                            canvas.width = 640;
                            canvas.height = 480;
                            const ctx = canvas.getContext('2d');
                            
                            // 模拟视频帧
                            let frameCount = 0;
                            function drawFrame() {
                                frameCount++;
                                
                                // 绘制简单的模拟桥梁场景
                                ctx.fillStyle = '#87CEEB'; // 天空
                                ctx.fillRect(0, 0, canvas.width, canvas.height);
                                
                                ctx.fillStyle = '#4682B4'; // 水
                                ctx.fillRect(0, 350, canvas.width, 130);
                                
                                // 桥梁主体
                                ctx.fillStyle = '#696969';
                                ctx.fillRect(0, 300, canvas.width, 50);
                                
                                // 桥墩
                                ctx.fillStyle = '#A9A9A9';
                                ctx.fillRect(100, 300, 30, 100);
                                ctx.fillRect(300, 300, 30, 110);
                                ctx.fillRect(500, 300, 30, 100);
                                
                                // 添加一些移动元素（车辆）
                                ctx.fillStyle = '#FF0000';
                                ctx.fillRect((frameCount * 2) % canvas.width, 280, 40, 20);
                                
                                ctx.fillStyle = '#0000FF';
                                ctx.fillRect((canvas.width - (frameCount * 3) % (canvas.width + 60)), 290, 60, 10);
                                
                                // 添加时间戳
                                ctx.fillStyle = '#FFFFFF';
                                ctx.font = '14px Arial';
                                ctx.fillText(`摄像头 #${cameraId} - ${new Date().toLocaleTimeString()}`, 10, 20);
                                ctx.fillText(`(模拟流 - ${streamUrl})`, 10, 40);
                                
                                // 为特定摄像头添加一些警告效果
                                if (cameraId === 5 || cameraId === 10) {
                                    if (frameCount % 30 < 15) {
                                        ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                                        
                                        ctx.fillStyle = '#FFFFFF';
                                        ctx.font = 'bold 24px Arial';
                                        ctx.fillText('检测到异常', canvas.width/2 - 60, canvas.height/2);
                                    }
                                }
                                
                                // 使用canvas作为视频源
                                videoElement.srcObject = canvas.captureStream(25); // 25fps
                                
                                // 继续下一帧
                                requestAnimationFrame(drawFrame);
                            }
                            
                            // 开始绘制帧
                            drawFrame();
                            
                            // 设置事件处理
                            videoElement.onloadedmetadata = () => {
                                videoElement.play().then(() => {
                                    console.log(`摄像头 #${cameraId} 模拟视频已启动`);
                                    resolve();
                                }).catch(error => {
                                    console.error(`摄像头 #${cameraId} 模拟视频播放失败:`, error);
                                    reject(error);
                                });
                            };
                            
                        } else {
                            // 生产环境 - 连接到实际的RTSP/HTTP流
                            // 注意：浏览器通常不能直接播放RTSP流，需要服务器端转换为HLS/DASH/WebRTC
                            
                            // 这里假设后端已经将RTSP流转换为HLS格式
                            console.log(`连接到实际视频流: ${streamUrl}`);
                            
                            // 此处需要根据后端API调整实现
                            // 例如：可能需要先调用API获取流的访问令牌
                            
                            // 模拟连接到基于HLS的流
                            videoElement.src = streamUrl.replace('rtsp://', 'https://') + '/index.m3u8';
                            videoElement.onerror = (error) => {
                                console.error(`加载视频流失败:`, error);
                                reject(new Error('无法加载视频流，请检查网络连接或联系系统管理员'));
                            };
                            
                            videoElement.onloadeddata = () => {
                                console.log(`摄像头 #${cameraId} 视频流已连接`);
                                resolve();
                            };
                        }
                    }, 1500); // 模拟连接延迟
                    
                } catch (error) {
                    console.error(`连接摄像头流时出错:`, error);
                    reject(error);
                }
            });
        }

        // 尝试重连摄像头
        function attemptReconnect(cameraId) {
            console.log(`尝试重连摄像头 #${cameraId}`);
            
            const cameraItem = document.querySelector(`.camera-item[data-camera-id="${cameraId}"]`);
            if (!cameraItem) return;
            
            // 修改摄像头占位符显示重连状态
            const placeholder = cameraItem.querySelector('.camera-placeholder');
            placeholder.querySelector('.camera-message').textContent = '正在尝试重新连接...';
            placeholder.querySelector('.camera-icon').textContent = 'sync';
            
            // 模拟重连过程
            let connectionAttempts = 0;
            const maxAttempts = 3;
            
            const attemptInterval = setInterval(() => {
                connectionAttempts++;
                console.log(`重连尝试 ${connectionAttempts}/${maxAttempts}`);
                
                if (connectionAttempts >= maxAttempts && Math.random() > 0.7) {
                    // 模拟重连成功
                    clearInterval(attemptInterval);
                    
                    // 更新状态为在线
                    const statusBadge = cameraItem.querySelector('.camera-status');
                    statusBadge.textContent = '在线';
                    statusBadge.className = 'camera-status online';
                    cameraItem.dataset.status = 'online';
                    
                    // 更新图标和消息
                    placeholder.querySelector('.camera-message').textContent = '摄像头已恢复连接';
                    placeholder.querySelector('.camera-icon').textContent = 'videocam';
                    
                    // 替换控制按钮
                    const cameraControls = cameraItem.querySelector('.camera-controls');
                    cameraControls.innerHTML = '';
                    
                    const controlButtons = [
                        { action: 'history', icon: 'history', text: '历史记录' },
                        { action: 'refresh', icon: 'refresh', text: '刷新' }
                    ];
                    
                    controlButtons.forEach(btn => {
                        const button = document.createElement('button');
                        button.className = 'camera-control-btn';
                        button.title = btn.text;
                        button.innerHTML = `<span class="material-icons">${btn.icon}</span>`;
                        button.dataset.action = btn.action;
                        button.dataset.camera = cameraId;
                        button.addEventListener('click', function() {
                            controlCamera(cameraId, btn.action);
                        });
                        cameraControls.appendChild(button);
                    });
                    
                    // 显示成功消息
                    showActionFeedback(cameraId, '摄像头已恢复连接');
                    
                    // 更新系统状态
                    updateSystemStatus();
                } else if (connectionAttempts >= maxAttempts) {
                    // 模拟重连失败
                    clearInterval(attemptInterval);
                    
                    // 恢复离线状态
                    placeholder.querySelector('.camera-message').textContent = '重连失败，摄像头离线';
                    placeholder.querySelector('.camera-icon').textContent = 'videocam_off';
                    
                    // 显示失败消息
                    showActionFeedback(cameraId, '重连失败');
                }
            }, 1000);
        }

        // 更新系统状态信息
        function updateSystemStatus() {
            // 统计摄像头状态
            const cameras = document.querySelectorAll('.camera-item');
            let onlineCount = 0;
            let offlineCount = 0;
            let warningCount = 0;
            
            cameras.forEach(camera => {
                const status = camera.dataset.status;
                if (status === 'online') onlineCount++;
                else if (status === 'offline') offlineCount++;
                else if (status === 'warning') warningCount++;
            });
            
            const systemStatus = document.getElementById('system-status');
            
            if (offlineCount > 0 || warningCount > 0) {
                let statusMessage = `摄像头状态: ${onlineCount} 在线`;
                if (warningCount > 0) statusMessage += `, ${warningCount} 警告`;
                if (offlineCount > 0) statusMessage += `, ${offlineCount} 离线`;
                
                systemStatus.textContent = statusMessage;
                
                if (offlineCount > 0) {
                    document.getElementById('cameraAlert').style.color = '#dc3545';
                } else {
                    document.getElementById('cameraAlert').style.color = '#ffc107';
                }
            } else {
                systemStatus.textContent = '监控系统运行正常，所有摄像头在线';
                document.getElementById('cameraAlert').style.color = '#28a745';
            }
        }

        // 模拟摄像头控制
        function controlCamera(cameraId, action) {
            console.log(`控制摄像头 #${cameraId}，动作: ${action}`);
            
            const cameraItem = document.querySelector(`.camera-item[data-camera-id="${cameraId}"]`);
            if (!cameraItem) return;
            
            // 显示控制反馈（闪烁效果）
            const placeholder = cameraItem.querySelector('.camera-placeholder');
            placeholder.style.opacity = '0.7';
            setTimeout(() => {
                placeholder.style.opacity = '1';
            }, 200);
            
            // 根据动作执行不同的模拟操作
            switch(action) {
                case 'history':
                    // 模拟查看历史记录
                    showActionFeedback(cameraId, '正在加载历史记录');
                    break;
                case 'refresh':
                    // 刷新摄像头
                    showActionFeedback(cameraId, '正在刷新连接');
                    break;
            }
        }

        // 显示摄像头操作反馈
        function showActionFeedback(cameraId, message) {
            try {
                console.log(`摄像头 #${cameraId} 操作反馈：${message}`);
                
                // 查找摄像头元素
            const cameraItem = document.querySelector(`.camera-item[data-camera-id="${cameraId}"]`);
            if (!cameraItem) return;
            
            // 创建反馈元素
            const feedback = document.createElement('div');
            feedback.className = 'camera-feedback';
            feedback.textContent = message;
            
                // 根据消息类型调整样式
                if (message.includes('错误') || message.includes('失败') || message.includes('离线')) {
                    feedback.classList.add('error');
                } else if (message.includes('警告') || message.includes('异常')) {
                    feedback.classList.add('warning');
                } else {
                    feedback.classList.add('success');
                }
                
                // 添加到摄像头元素
                cameraItem.appendChild(feedback);
                
                // 设置自动消失
                setTimeout(() => {
                    feedback.classList.add('fade-out');
            setTimeout(() => {
                if (feedback.parentNode) {
                            feedback.parentNode.removeChild(feedback);
                        }
                    }, 500);
                }, 3000);
                
                // 添加关闭按钮
                const closeBtn = document.createElement('span');
                closeBtn.className = 'feedback-close';
                closeBtn.innerHTML = '&times;';
                closeBtn.addEventListener('click', function() {
                    if (feedback.parentNode) {
                        feedback.parentNode.removeChild(feedback);
                    }
                });
                feedback.appendChild(closeBtn);
                
            } catch (error) {
                console.error('显示摄像头操作反馈时出错:', error);
            }
        }

        // 标签页切换功能
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', function() {
                const tabId = this.getAttribute('data-tab');
                
                // 更新标签页状态
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                this.classList.add('active');
                
                // 更新内容区域
                document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
                document.getElementById(`${tabId}-tab`).classList.add('active');
                
                // 如果切换到监控标签，初始化相应功能
                if (tabId === 'monitor') {
                    // 初始化摄像头监控而不是桥梁监控
                    initCameraMonitor();
                }
            });
        });

        // 重置所有数据和状态
        function resetAll() {
            try {
                // 重置数据
                window.sensorData = [];
                
                // 重置文件输入
                if (fileInput) fileInput.value = '';
                if (fileInfo) fileInfo.textContent = '未选择文件';
                if (uploadButton) uploadButton.disabled = true;
                if (detectButton) detectButton.disabled = true;  // 确保检测按钮初始状态为禁用
                
                // 清除表格数据
                if (dataTable) {
                    const tableBody = dataTable.getElementsByTagName('tbody')[0];
                    if (tableBody) tableBody.innerHTML = '';
                }
                if (noDataMessage) noDataMessage.style.display = 'block';
                
                // 清除图表
                if (window.dataChart) {
                    try {
                        if (typeof window.dataChart.destroy === 'function') {
                            window.dataChart.destroy();
                        } else {
                            console.log("Chart没有destroy方法，尝试其他方式清除");
                            // 如果没有destroy方法，尝试释放Canvas资源
                            const chartCanvas = document.getElementById('dataChart');
                            if (chartCanvas) {
                                const ctx = chartCanvas.getContext('2d');
                                if (ctx) {
                                    ctx.clearRect(0, 0, chartCanvas.width, chartCanvas.height);
                                }
                            }
                        }
                    } catch (chartError) {
                        console.error("清除图表时出错:", chartError);
                    }
                    window.dataChart = null;
                }
                if (noChartDataMessage) noChartDataMessage.style.display = 'block';
                
                // 清除异常分析结果
                if (noAnalysisMessage) noAnalysisMessage.style.display = 'block';
                if (analysisLoader) analysisLoader.style.display = 'none';
                if (analysisSummary) analysisSummary.style.display = 'none';
                if (anomalyList) anomalyList.innerHTML = '';
                
                // 隐藏桥梁监控
                if (noMonitorMessage) noMonitorMessage.style.display = 'block';
                
                // 停止数据更新
                if (typeof stopDataUpdates === 'function') {
                    stopDataUpdates();
                } else if (window.dataUpdateInterval) {
                    clearInterval(window.dataUpdateInterval);
                    window.dataUpdateInterval = null;
                }
                
                // 切换到数据查看标签
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                const dataTab = document.querySelector('.tab[data-tab="data"]');
                if (dataTab) dataTab.classList.add('active');
                
                document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
                const dataTabContent = document.getElementById('data-tab');
                if (dataTabContent) dataTabContent.classList.add('active');
            } catch (error) {
                console.error('重置过程中出错:', error);
            }
        }

        // 格式化文件大小
        function formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            else if (bytes < 1048576) return (bytes / 1024).toFixed(1) + ' KB';
            else return (bytes / 1048576).toFixed(1) + ' MB';
        }

        // 定义传感器值范围
        const sensorRanges = {
            '温度': {
                normal: [-10, 45],   // 正常温度范围 (°C)
                warning: [-20, 50],  // 警告温度范围
                critical: [-30, 60]  // 危险温度范围
            },
            '应变': {
                normal: [0, 500],    // 正常应变范围 (微应变)
                warning: [500, 800], // 警告应变范围
                critical: [800, 1000] // 危险应变范围
            },
            '振动': {
                normal: [0, 20],     // 正常振动范围 (mm/s)
                warning: [20, 40],   // 警告振动范围
                critical: [40, 100]  // 危险振动范围
            },
            '倾角': {
                normal: [-2, 2],     // 正常倾角范围 (°)
                warning: [-4, 4],    // 警告倾角范围
                critical: [-8, 8]    // 危险倾角范围
            }
        };

        // 生成示例数据
        function createSampleData() {
            try {
                // 重置现有数据
                window.sensorData = [];
                
                // 当前时间
                const now = new Date();
                
                // 不同类型的传感器
                const sensorTypes = [
                    { id: '温度传感器-主桥北段', type: '温度' },
                    { id: '温度传感器-主桥中段', type: '温度' },
                    { id: '温度传感器-主桥南段', type: '温度' },
                    { id: '应变传感器-主桥北段', type: '应变' },
                    { id: '应变传感器-主桥中段', type: '应变' },
                    { id: '应变传感器-主桥南段', type: '应变' },
                    { id: '振动传感器-主桥北段', type: '振动' },
                    { id: '振动传感器-主桥中段', type: '振动' },
                    { id: '振动传感器-主桥南段', type: '振动' },
                    { id: '倾角传感器-主桥北段', type: '倾角' },
                    { id: '倾角传感器-主桥中段', type: '倾角' },
                    { id: '倾角传感器-主桥南段', type: '倾角' }
                ];
                
                // 确保每次生成的数据至少包含一个异常值
                let hasAnomalyPoint = false;
                
                // 随机选择一个传感器和一个时间点用于确保创建异常值
                const anomalySensorIndex = Math.floor(Math.random() * sensorTypes.length);
                const anomalyTimeIndex = Math.floor(Math.random() * 48);
                
                // 为每种传感器生成数据
                sensorTypes.forEach((sensor, sensorIndex) => {
                    // 确定传感器类型
                    const range = sensorRanges[sensor.type];
                    const baseValue = (range.normal[0] + range.normal[1]) / 2;
                    
                    // 生成48个数据点，每30分钟一个
                    for (let i = 0; i < 48; i++) {
                        const timestamp = new Date(now.getTime() - (47-i) * 30 * 60 * 1000); // 30分钟间隔
                        const timeStr = timestamp.toLocaleString('zh-CN', {
                            year: 'numeric',
                            month: '2-digit',
                            day: '2-digit',
                            hour: '2-digit',
                            minute: '2-digit'
                        }).replace(',', ' ');
                        
                        // 根据传感器类型和时间生成合理的数据变化
                        // 添加周期性变化和一些噪声
                        const hourFactor = Math.sin((timestamp.getHours() / 24) * Math.PI * 2);
                        const dayCycle = hourFactor * 0.2 * baseValue; // 昼夜循环
                        
                        // 为不同传感器类型使用不同的波动函数
                        let cyclicChange = 0;
                        if (sensor.type === '温度') {
                            cyclicChange = Math.sin(i/12) * 5 + dayCycle;
                        } else if (sensor.type === '应变') {
                            cyclicChange = Math.sin(i/8) * 10 + dayCycle * 0.5;
                        } else if (sensor.type === '振动') {
                            cyclicChange = Math.sin(i/6) * 8 + Math.cos(i/10) * 5;
                        } else if (sensor.type === '倾角') {
                            cyclicChange = Math.sin(i/10) * 0.8 + Math.cos(i/15) * 0.6;
                        }
                        
                        // 添加随机噪声
                        const noise = (Math.random() - 0.5) * 0.05 * baseValue;
                        
                        // 计算最终值
                        let value = baseValue + cyclicChange + noise;
                        
                        // 插入异常值 - 增加概率到20%
                        let isAnomaly = Math.random() < 0.2;
                        
                        // 确保至少有一个异常值 - 为指定的传感器和时间点强制创建异常值
                        if (sensorIndex === anomalySensorIndex && i === anomalyTimeIndex) {
                            isAnomaly = true;
                            hasAnomalyPoint = true;
                        }
                        
                        if (isAnomaly) {
                            // 异常值偏离幅度更大
                            const anomalyFactor = (Math.random() < 0.5 ? 1 : -1) * (Math.random() * 0.5 + 0.3);
                            value += anomalyFactor * baseValue;
                        }
                        
                        // 确保在有效范围内
                        const min = range.normal[0] - Math.abs(range.normal[0] * 0.5);
                        const max = range.critical[1];
                        value = Math.max(min, Math.min(max, value));
                        
                        // 确定状态
                        let status = 'normal';
                        if (value < range.normal[0] || value > range.normal[1]) {
                            if (value < range.warning[0] || value > range.warning[1]) {
                                status = 'danger';
                            } else {
                                status = 'warning';
                            }
                        }
                        
                        // 添加到数据数组
                        window.sensorData.push({
                            timestamp: timeStr,
                            sensorId: sensor.id,
                            sensorType: sensor.type,
                            value: parseFloat(value.toFixed(2)),
                            status: status
                        });
                    }
                });
                
                // 如果没有自然生成的异常值，强制在随机位置创建一个
                if (!hasAnomalyPoint) {
                    const randomIndex = Math.floor(Math.random() * window.sensorData.length);
                    const dataPoint = window.sensorData[randomIndex];
                    const range = sensorRanges[dataPoint.sensorType];
                    
                    // 创建明显的异常值
                    const baseValue = (range.normal[0] + range.normal[1]) / 2;
                    const anomalyFactor = (Math.random() < 0.5 ? 1 : -1) * 0.8;
                    let anomalyValue = baseValue + (anomalyFactor * baseValue);
                    
                    // 确保在范围内但异常
                    anomalyValue = Math.max(range.warning[1] + 1, Math.min(range.critical[1], anomalyValue));
                    
                    // 更新数据点
                    window.sensorData[randomIndex].value = parseFloat(anomalyValue.toFixed(2));
                    window.sensorData[randomIndex].status = 'danger';
                }
                
                // 确保检测按钮启用
                if (detectButton) detectButton.disabled = false;
                
                // 更新显示
                displayData();
                createChart();
                
                console.log("示例数据已生成，包含", window.sensorData.length, "个数据点");
            } catch (error) {
                console.error("生成示例数据出错:", error);
                alert("生成示例数据时出错: " + error.message);
            }
        }
        
        // 生成并下载示例文件
        function generateExampleFile() {
            // 阻止默认链接点击行为
            event.preventDefault();
            
            // 生成示例数据
            const exampleData = [];
            const now = new Date();
            
            // 添加表头
            exampleData.push("时间戳,传感器ID,数值");
            
            // 传感器类型与ID定义，确保与createSampleData函数保持一致
            const sensorTypes = [
                { id: '温度传感器-主桥北段', type: '温度', baseValue: 25 },
                { id: '温度传感器-主桥中段', type: '温度', baseValue: 27 },
                { id: '温度传感器-主桥南段', type: '温度', baseValue: 26 },
                { id: '应变传感器-主桥北段', type: '应变', baseValue: 200 },
                { id: '应变传感器-主桥中段', type: '应变', baseValue: 210 },
                { id: '应变传感器-主桥南段', type: '应变', baseValue: 220 },
                { id: '振动传感器-主桥北段', type: '振动', baseValue: 0.5 },
                { id: '振动传感器-主桥中段', type: '振动', baseValue: 0.4 },
                { id: '振动传感器-主桥南段', type: '振动', baseValue: 0.6 },
                { id: '倾角传感器-主桥北段', type: '倾角', baseValue: 0.2 },
                { id: '倾角传感器-主桥中段', type: '倾角', baseValue: 0.3 },
                { id: '倾角传感器-主桥南段', type: '倾角', baseValue: 0.1 }
            ];
            
            // 为每个传感器生成数据点
            sensorTypes.forEach(sensor => {
                for (let i = 0; i < 20; i++) {
                    const timestamp = new Date(now.getTime() - (19-i) * 30 * 60 * 1000); // 30分钟间隔
                    const timeStr = timestamp.toLocaleString('zh-CN', {
                        year: 'numeric',
                        month: '2-digit',
                        day: '2-digit',
                        hour: '2-digit',
                        minute: '2-digit'
                    }).replace(',', ' ');
                    
                    // 根据传感器类型生成不同的波动模式
                    let value = sensor.baseValue;
                    
                    if (sensor.type === '温度') {
                        value += Math.sin(i/3) * 2 + (Math.random() - 0.5);
                    } else if (sensor.type === '应变') {
                        value += Math.sin(i/4) * 15 + (Math.random() - 0.5) * 5;
                    } else if (sensor.type === '振动') {
                        value += Math.sin(i/2) * 0.1 + (Math.random() - 0.5) * 0.1;
                        // 添加一个异常值
                        if (i === 10 && sensor.id === '振动传感器-主桥南段') value = 1.2;
                    } else if (sensor.type === '倾角') {
                        value += Math.sin(i/3) * 0.1 + (Math.random() - 0.5) * 0.05;
                    }
                    
                    exampleData.push(`${timeStr},${sensor.id},${value.toFixed(2)}`);
                }
            });
            
            // 将示例数据转换为CSV文本
            const csvContent = exampleData.join('\n');
            
            // 创建Blob对象
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            
            // 创建下载链接
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            link.setAttribute('href', url);
            link.setAttribute('download', '桥梁监测数据示例.csv');
            link.style.visibility = 'hidden';
            
            // 添加到DOM，触发下载，然后移除
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            console.log("已生成包含各类传感器的示例数据文件");
        }
        
        // 随机刷新数据功能
        function startRandomDataUpdates() {
            // 停止之前的更新
            stopDataUpdates();
            
            // 确保有数据
            if (!sensorData || sensorData.length === 0) {
                alert('请先上传数据或生成示例数据');
                return;
            }
            
            // 显示正在刷新提示
            fileInfo.textContent = '数据刷新中...';
            refreshButton.textContent = '停止刷新';
            refreshButton.classList.add('danger');
            
            // 启用检测按钮，确保在数据刷新时可以进行检测
            detectButton.disabled = false;
            
            // 每5秒更新一次数据（更符合桥梁监测的实际频率）
            dataUpdateInterval = setInterval(() => {
                randomlyUpdateData();
            }, 5000);
        }
        
        // 停止数据更新
        function stopDataUpdates() {
            if (dataUpdateInterval) {
                clearInterval(dataUpdateInterval);
                dataUpdateInterval = null;
                
                refreshButton.textContent = '随机刷新数据';
                refreshButton.classList.remove('danger');
                
                if (fileInput.files.length > 0) {
                    const file = fileInput.files[0];
                    fileInfo.textContent = `已选择文件: ${file.name} (${formatFileSize(file.size)})`;
                } else {
                    fileInfo.textContent = '未选择文件';
                }
            }
        }
        
        // 随机更新数据，使模拟数据更符合物理现实
        function randomlyUpdateData() {
            if (!sensorData || sensorData.length === 0) return;
            
            // 获取当前时间作为新的数据点时间戳
            const now = new Date();
            const timeStr = now.toLocaleString('zh-CN', {
                year: 'numeric',
                month: '2-digit',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit'
            });
            
            // 获取唯一的传感器ID列表
            const uniqueSensors = [...new Set(sensorData.map(item => item.sensorId))];
            
            // 创建环境因素，确保数据之间的关联性
            const environmentalFactor = Math.sin(Date.now() / 10000000) * 0.15; // 缓慢变化的环境因素
            const timeOfDayFactor = Math.sin(now.getHours() / 24 * Math.PI) * 0.1; // 日间变化因素
            const bridgeLoadFactor = Math.sin(Date.now() / 3600000) * 0.08; // 桥梁负载变化
            
            // 随机选择一个传感器来确保创建异常值
            const anomalySensorIndex = Math.floor(Math.random() * uniqueSensors.length);
            let hasCreatedAnomaly = false;
            
            // 为每个传感器创建新的数据点
            uniqueSensors.forEach((sensorId, sensorIndex) => {
                // 获取该传感器的历史数据
                const sensorPoints = sensorData.filter(item => item.sensorId === sensorId);
                const lastPoint = sensorPoints[sensorPoints.length - 1];
                const currentValue = parseFloat(lastPoint.value);
                
                // 确定传感器类型
                let sensorType = '其他';
                if (sensorId.includes('温度')) sensorType = '温度';
                else if (sensorId.includes('应变')) sensorType = '应变';
                else if (sensorId.includes('振动')) sensorType = '振动';
                else if (sensorId.includes('倾角')) sensorType = '倾角';
                
                // 确定传感器位置
                let sensorLocation = '中段';
                for (const section of ['北段', '中段', '南段', '东段', '西段']) {
                    if (sensorId.includes(section)) {
                        sensorLocation = section;
                        break;
                    }
                }
                
                // 根据传感器类型获取数据范围
                const range = sensorRanges[sensorType] || {
                    normal: [0, 100],
                    warning: [-10, 110],
                    critical: [-20, 120],
                    min: -20,
                    max: 120,
                    warningThreshold: 110,
                    alarmThreshold: 120
                };
                
                // 计算基础变化量
                const randomFactor = (Math.random() * 2 - 1) * 0.01 * currentValue;
                
                // 环境因素影响
                let environmentalImpact = 0;
                if (sensorType === '温度') {
                    environmentalImpact = environmentalFactor * 4 + timeOfDayFactor * 2;
                } else if (sensorType === '应变') {
                    environmentalImpact = bridgeLoadFactor * 50 + timeOfDayFactor * 25;
                } else if (sensorType === '振动') {
                    environmentalImpact = bridgeLoadFactor * 2 + environmentalFactor * 1;
                } else if (sensorType === '倾角') {
                    environmentalImpact = bridgeLoadFactor * 0.4 + environmentalFactor * 0.5;
                } else {
                    environmentalImpact = environmentalFactor * 10 + timeOfDayFactor * 5;
                }
                
                // 总变化量 = 环境影响 + 随机噪声
                let baseChange = environmentalImpact + randomFactor;
                
                // 计算新值
                let newValue = currentValue + baseChange;
                
                // 检查是否创建异常值 - 增加概率到15%
                let isAnomaly = Math.random() < 0.15;
                
                // 确保至少有一个异常值 - 为指定的传感器强制创建异常值
                if (sensorIndex === anomalySensorIndex && !hasCreatedAnomaly) {
                    isAnomaly = true;
                    hasCreatedAnomaly = true;
                }
                
                if (isAnomaly) {
                    // 创建明显的异常值
                    const baseValue = (range.normal[0] + range.normal[1]) / 2;
                    const anomalyFactor = (Math.random() < 0.5 ? 1 : -1) * (Math.random() * 0.4 + 0.3);
                    newValue = baseValue + (anomalyFactor * baseValue);
                    
                    // 确保异常值明显偏离但不超出有效范围
                    newValue = Math.max(range.normal[0] - Math.abs(range.normal[0] * 0.4), 
                                      Math.min(range.critical[1], newValue));
                }
                
                // 确定传感器状态
                let status = 'normal';
                if (newValue < range.normal[0] || newValue > range.normal[1]) {
                    if (newValue < range.warning[0] || newValue > range.warning[1]) {
                        status = 'danger';
                    } else {
                        status = 'warning';
                    }
                }
                
                // 添加新的数据点
                sensorData.push({
                    timestamp: timeStr,
                    sensorId: sensorId,
                    sensorType: sensorType,
                    value: parseFloat(newValue.toFixed(2)),
                    status: status
                });
                
                // 保持数据点数量在一个合理范围内（每个传感器最多保留100个点）
                const maxPointsPerSensor = 100;
                const currentPoints = sensorData.filter(item => item.sensorId === sensorId);
                if (currentPoints.length > maxPointsPerSensor) {
                    // 找到并移除最早的数据点
                    const oldestIndex = sensorData.findIndex(item => item.sensorId === sensorId);
                    if (oldestIndex !== -1) {
                        sensorData.splice(oldestIndex, 1);
                    }
                }
            });
            
            // 更新显示和图表
            displayData();
            createChart();
            
            // 确保检测按钮启用
            if (detectButton) detectButton.disabled = false;
        }

        // 添加示例数据按钮和下载示例文件功能
        document.getElementById('sampleButton').addEventListener('click', function() {
            // 生成示例数据
            createSampleData();
            
            // 确保检测按钮启用
            detectButton.disabled = false;
        });
        downloadExample.addEventListener('click', generateExampleFile);
        
        // 随机刷新按钮点击事件
        refreshButton.addEventListener('click', function() {
            if (dataUpdateInterval) {
                stopDataUpdates();
            } else {
                startRandomDataUpdates();
            }
        });
        
        // 处理上传的数据
        function processData(content) {
            try {
                const lines = content.split('\n');
                console.log("文件行数:", lines.length);
                
                window.sensorData = [];
                
                let validLines = 0;
                let skippedLines = 0;
                
                // 跳过第一行（标题行）
                const hasHeader = lines.length > 0 && lines[0].includes('时间戳') && lines[0].includes('传感器ID');
                const startLine = hasHeader ? 1 : 0;
                
                for (let i = startLine; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (line !== '') {
                        const parts = line.split(',');
                        // 修改逻辑，支持更灵活的数据格式
                        if (parts.length >= 2) {
                            try {
                                const timestamp = parts[0].trim();
                                const sensorId = parts.length >= 3 ? parts[1].trim() : `传感器${i+1}`;
                                const valueIndex = parts.length >= 3 ? 2 : 1;
                                const valueStr = parts[valueIndex].trim();
                                const value = parseFloat(valueStr);
                                
                                if (!isNaN(value)) {
                                    // 从传感器ID中确定传感器类型
                                    let sensorType = '其他';
                                    if (sensorId.includes('温度')) sensorType = '温度';
                                    else if (sensorId.includes('应变')) sensorType = '应变';
                                    else if (sensorId.includes('振动')) sensorType = '振动';
                                    else if (sensorId.includes('倾角')) sensorType = '倾角';
                                    
                                    // 从传感器类型获取数据范围，用于确定状态
                                    const range = sensorRanges[sensorType] || {
                                        normal: [0, 100],
                                        warning: [-10, 110],
                                        critical: [-20, 120]
                                    };
                                    
                                    // 确定状态
                                    let status = 'normal';
                                    if (value < range.normal[0] || value > range.normal[1]) {
                                        if (value < range.warning[0] || value > range.warning[1]) {
                                            status = 'danger';
                                        } else {
                                            status = 'warning';
                                        }
                                    }
                                    
                                    window.sensorData.push({
                                        timestamp: timestamp,
                                        sensorId: sensorId,
                                        sensorType: sensorType,
                                        value: value,
                                        status: status
                                    });
                                    validLines++;
                                } else {
                                    console.warn(`第${i+1}行数值无效: "${valueStr}"`);
                                    skippedLines++;
                                }
                            } catch (e) {
                                console.warn(`解析第${i+1}行时出错:`, e.message, "行内容:", line);
                                skippedLines++;
                            }
                        } else {
                            console.warn(`第${i+1}行格式不正确，至少需要2个值: ${line}`);
                            skippedLines++;
                        }
                    }
                }
                
                console.log(`数据处理完成: 有效行数=${validLines}, 跳过行数=${skippedLines}`);
                
                // 确保即使没有数据也不会报错
                if (window.sensorData.length === 0) {
                    console.warn("没有找到有效数据");
                    if (noDataMessage) noDataMessage.style.display = 'block';
                    return;
                }
                
                displayData();
                createChart();
                initBridgeMonitor();
                
            } catch (error) {
                console.error("处理数据时发生错误:", error);
                alert("处理数据时发生错误: " + error.message);
            }
        }
        
        // 初始化
        resetAll();
        // 检查登录状态
        checkLoginStatus();
        // 初始化事件控制面板
        initEventControls();

        // 确定异常类型
        function determineAnomalyType(index, values, zScore) {
            try {
                // 检查前后是否也是异常，判断连续性异常
                let isContinuous = false;
                
                if (index > 1) {  // 确保有前两个点
                    try {
                        isContinuous = Math.abs((values[index-1] - values[index-2]) / Math.max(0.01, Math.abs(values[index-2]))) > 0.1;
                    } catch (e) {
                        console.warn("计算前导点连续性异常时出错:", e.message);
                    }
                }
                
                if (!isContinuous && index < values.length - 1) {  // 检查后一个点
                    try {
                        isContinuous = Math.abs((values[index+1] - values[index]) / Math.max(0.01, Math.abs(values[index]))) > 0.1;
                    } catch (e) {
                        console.warn("计算后继点连续性异常时出错:", e.message);
                    }
                }
                
                // 检查周围点是否形成群体
                const startIdx = Math.max(0, index - 3);
                const endIdx = Math.min(values.length, index + 4);
                const nearbyPoints = values.slice(startIdx, endIdx);
                
                const nearbyMean = nearbyPoints.reduce((acc, val) => acc + val, 0) / nearbyPoints.length;
                const globalMean = values.reduce((acc, val) => acc + val, 0) / values.length;
                
                // 避免除以零，加入安全检查
                const denominator = Math.max(0.01, Math.abs(globalMean));
                const isCluster = Math.abs((nearbyMean - globalMean) / denominator) > 0.1 && nearbyPoints.length >= 3;
                
                if (isCluster) {
                    return '群体异常';
                } else if (isContinuous) {
                    return '连续性异常';
                } else {
                    return '单点异常';
                }
            } catch (error) {
                console.error("确定异常类型时出错:", error);
                return '未分类异常';  // 返回一个默认值
            }
        }

        // 格式化日期时间
        function formatDateTime(date) {
            const dt = new Date(date);
            const year = dt.getFullYear();
            const month = String(dt.getMonth() + 1).padStart(2, '0');
            const day = String(dt.getDate()).padStart(2, '0');
            const hours = String(dt.getHours()).padStart(2, '0');
            const minutes = String(dt.getMinutes()).padStart(2, '0');
            const seconds = String(dt.getSeconds()).padStart(2, '0');
            
            return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
        }

        // 模拟Chrome扩展API以防止错误
        if (typeof chrome === 'undefined' || !chrome.runtime) {
            window.chrome = window.chrome || {};
            chrome.runtime = chrome.runtime || {};
            
            // 模拟runtime.sendMessage和onMessage以防止错误
            const originalConsoleError = console.error;
            console.error = function(...args) {
                // 过滤掉关于chrome.runtime的错误消息
                if (args && args[0] && typeof args[0] === 'string' && 
                    (args[0].includes('chrome.runtime') || 
                     args[0].includes('Receiving end does not exist') || 
                     args[0].includes('message port closed'))) {
                    return; // 不打印Chrome扩展相关错误
                }
                originalConsoleError.apply(console, args);
            };
            
            // 创建无操作函数
            chrome.runtime.sendMessage = function() {
                return Promise.resolve();
            };
            chrome.runtime.onMessage = {
                addListener: function() {},
                removeListener: function() {}
            };
        }

        // 数据显示函数
        function displayData() {
            try {
                console.log("开始显示数据...");
                // 检查数据是否存在
                if (!window.sensorData || window.sensorData.length === 0) {
                    if (noDataMessage) noDataMessage.style.display = 'block';
                    if (dataTable) {
                        const tableBody = dataTable.getElementsByTagName('tbody')[0];
                        if (tableBody) tableBody.innerHTML = '';
                    }
                    console.log("没有数据可显示");
                    return;
                }
                
                // 打印传感器类型分布数据，用于调试
                const typeCounts = {};
                window.sensorData.forEach(data => {
                    const type = data.sensorType || '未知';
                    typeCounts[type] = (typeCounts[type] || 0) + 1;
                });
                console.log("数据类型分布:", JSON.stringify(typeCounts));
                
                // 隐藏无数据消息
                if (noDataMessage) noDataMessage.style.display = 'none';
                
                // 获取表格主体并清空
                if (!dataTable) {
                    console.error("未找到数据表格元素");
                    return;
                }
                const tableBody = dataTable.getElementsByTagName('tbody')[0];
                if (!tableBody) {
                    console.error("未找到表格主体元素");
                    return;
                }
                tableBody.innerHTML = '';
                
                // 显示前50条数据
                const maxDisplay = Math.min(50, window.sensorData.length);
                
                // 按照时间降序排序所有数据
                const sortedData = [...window.sensorData];
                sortedData.sort((a, b) => {
                    return new Date(b.timestamp) - new Date(a.timestamp);
                });
                
                // 取前N条数据
                const latestData = sortedData.slice(0, maxDisplay);
                
                // 确保显示各种类型的传感器数据
                const typeFilters = ['温度', '应变', '振动', '倾角'];
                let dataToShow = [];
                
                // 为每种传感器类型选择一些数据点
                typeFilters.forEach(type => {
                    const typeData = latestData.filter(data => data.sensorType === type);
                    if (typeData.length > 0) {
                        // 每种类型最多取10个数据点
                        dataToShow = dataToShow.concat(typeData.slice(0, 10));
                    }
                });
                
                // 如果按类型筛选后数据太少，补充其他数据
                if (dataToShow.length < maxDisplay) {
                    const otherData = latestData.filter(data => !dataToShow.includes(data));
                    dataToShow = dataToShow.concat(otherData.slice(0, maxDisplay - dataToShow.length));
                }
                
                // 再次按时间排序
                dataToShow.sort((a, b) => {
                    return new Date(b.timestamp) - new Date(a.timestamp);
                });
                
                dataToShow.forEach(data => {
                    const row = document.createElement('tr');
                    
                    // 添加传感器类型标识
                    if (data.sensorType) {
                        row.classList.add(`type-${data.sensorType}`);
                    }
                    
                    // 根据状态添加类
                    if (data.status === 'warning') {
                        row.classList.add('warning-row');
                    } else if (data.status === 'danger' || data.status === 'alarm') {
                        row.classList.add('danger-row');
                    }
                    
                    // 创建并添加单元格
                    const timestampCell = document.createElement('td');
                    timestampCell.textContent = data.timestamp;
                    row.appendChild(timestampCell);
                    
                    const sensorCell = document.createElement('td');
                    sensorCell.textContent = data.sensorId;
                    
                    // 添加传感器类型作为标记
                    if (data.sensorType) {
                        const typeSpan = document.createElement('span');
                        typeSpan.className = 'sensor-type-tag';
                        typeSpan.textContent = data.sensorType;
                        sensorCell.appendChild(document.createElement('br'));
                        sensorCell.appendChild(typeSpan);
                    }
                    
                    row.appendChild(sensorCell);
                    
                    const valueCell = document.createElement('td');
                    valueCell.textContent = data.value;
                    row.appendChild(valueCell);
                    
                    const statusCell = document.createElement('td');
                    const statusBadge = document.createElement('span');
                    statusBadge.classList.add('status-badge');
                    
                    if (data.status === 'normal') {
                        statusBadge.classList.add('status-normal');
                        statusBadge.textContent = '正常';
                    } else if (data.status === 'warning') {
                        statusBadge.classList.add('status-warning');
                        statusBadge.textContent = '警告';
                    } else {
                        statusBadge.classList.add('status-danger');
                        statusBadge.textContent = '危险';
                    }
                    
                    statusCell.appendChild(statusBadge);
                    row.appendChild(statusCell);
                    
                    // 添加行到表格
                    tableBody.appendChild(row);
                });
                
                console.log(`显示了 ${dataToShow.length} 条数据，包含多种传感器类型`);
            } catch (error) {
                console.error('显示数据时出错:', error);
            }
        }
        
        // 创建图表函数
        function createChart() {
            try {
                // 检查是否有Chart对象
                if (typeof Chart === 'undefined') {
                    console.error('Chart.js 未加载');
                    return;
                }
                
                // 检查数据是否存在
                if (!window.sensorData || window.sensorData.length === 0) {
                    if (noChartDataMessage) noChartDataMessage.style.display = 'block';
                    return;
                }
                
                // 找到图表容器
                const chartContainer = document.getElementById('chart-container');
                if (!chartContainer) {
                    console.error('未找到图表容器');
                    return;
                }
                
                // 隐藏无数据消息
                if (noChartDataMessage) noChartDataMessage.style.display = 'none';
                
                // 清空现有图表容器
                chartContainer.innerHTML = '';
                
                // 按传感器类型对数据进行分组
                const sensorsByType = {};
                window.sensorData.forEach(data => {
                    const sensorType = data.sensorType || '未知类型';
                    
                    if (!sensorsByType[sensorType]) {
                        sensorsByType[sensorType] = {};
                    }
                    
                    if (!sensorsByType[sensorType][data.sensorId]) {
                        sensorsByType[sensorType][data.sensorId] = [];
                    }
                    
                    sensorsByType[sensorType][data.sensorId].push({
                        x: data.timestamp,
                        y: parseFloat(data.value),
                        status: data.status,
                        sensorId: data.sensorId
                    });
                });
                
                // 颜色映射
                const colors = [
                    '#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', 
                    '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', 
                    '#bcbd22', '#17becf'
                ];
                
                // 为每种传感器类型创建一个图表
                Object.keys(sensorsByType).forEach((sensorType, typeIndex) => {
                    // 创建传感器类型标题
                    const typeHeader = document.createElement('h3');
                    typeHeader.className = 'sensor-type-header';
                    typeHeader.textContent = `${sensorType}传感器数据`;
                    typeHeader.style.marginTop = '20px';
                    typeHeader.style.color = '#2c5282';
                    chartContainer.appendChild(typeHeader);
                    
                    // 创建图表容器
                    const chartDiv = document.createElement('div');
                    chartDiv.className = 'chart-wrapper';
                    chartDiv.style.height = '300px';
                    chartDiv.style.marginBottom = '20px';
                    chartContainer.appendChild(chartDiv);
                    
                    // 创建Canvas元素
                    const canvas = document.createElement('canvas');
                    canvas.id = `chart-${sensorType.replace(/[^a-zA-Z0-9]/g, '-')}`;
                    chartDiv.appendChild(canvas);
                    
                    // 准备数据集
                    const datasets = [];
                    let sensorIndex = 0;
                    
                    Object.keys(sensorsByType[sensorType]).forEach(sensorId => {
                    // 对数据按时间排序
                        sensorsByType[sensorType][sensorId].sort((a, b) => new Date(a.x) - new Date(b.x));
                    
                    // 取最后25个点以避免过度拥挤
                        const points = sensorsByType[sensorType][sensorId].slice(-25);
                    
                    datasets.push({
                        label: sensorId,
                        data: points,
                            borderColor: colors[sensorIndex % colors.length],
                            backgroundColor: colors[sensorIndex % colors.length] + '20',
                        pointRadius: 4,
                        pointHoverRadius: 6,
                        pointBackgroundColor: function(context) {
                            const point = context.dataset.data[context.dataIndex];
                            if (point.status === 'danger' || point.status === 'alarm') {
                                return '#dc3545';
                            } else if (point.status === 'warning') {
                                return '#ffc107';
                            }
                                return colors[sensorIndex % colors.length];
                        },
                        pointBorderColor: '#fff',
                        pointBorderWidth: 1.5,
                        tension: 0.2
                    });
                        
                        sensorIndex++;
                });
                
                // 创建图表
                    new Chart(canvas, {
                    type: 'line',
                    data: {
                        datasets: datasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: {
                                type: 'category',
                                title: {
                                    display: true,
                                    text: '时间'
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                        text: `${sensorType}值`
                                }
                            }
                        },
                        plugins: {
                                title: {
                                    display: true,
                                    text: `${sensorType}传感器数据可视化`,
                                    font: {
                                        size: 16,
                                        weight: 'bold'
                                    }
                                },
                            legend: {
                                position: 'top',
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const point = context.dataset.data[context.dataIndex];
                                        let status = '正常';
                                        if (point.status === 'warning') status = '警告';
                                        if (point.status === 'danger' || point.status === 'alarm') status = '危险';
                                        return `${context.dataset.label}: ${point.y} (${status})`;
                                    }
                                }
                            }
                        }
                    }
                });
                
                    console.log(`已创建 ${sensorType} 类型传感器的图表，包含 ${datasets.length} 个传感器`);
                });
                
            } catch (error) {
                console.error('创建图表时出错:', error);
            }
        }
        
        // 初始化事件控制面板函数
        function initEventControls() {
            try {
                // 这里是事件控制面板的初始化代码
                console.log('事件控制面板已初始化');
            } catch (error) {
                console.error('初始化事件控制面板时出错:', error);
            }
        }

        // 替换登录状态检查函数，因为我们已经移除了登录功能
        function checkLoginStatus() {
            console.log('已跳过登录检查，系统直接进入');
            // 不执行任何操作，仅作为兼容旧代码的存根函数
        }
        
        // 添加异常检测启动函数
        function startAnomalyDetection() {
            try {
                // 检查是否有数据
                if (!window.sensorData || window.sensorData.length === 0) {
                    alert('没有数据可供检测!');
                    return;
                }

                // 显示加载动画
                if (analysisLoader) analysisLoader.style.display = 'block';
                if (noAnalysisMessage) noAnalysisMessage.style.display = 'none';
                if (analysisSummary) analysisSummary.style.display = 'none';
                if (anomalyList) anomalyList.innerHTML = '';
                
                // 显示分析内容区域
                const analysisContent = document.getElementById('analysis-content');
                if (analysisContent) analysisContent.style.display = 'block';
                
                // 模拟异常检测过程 - 真实场景中这应该调用异常检测算法
                setTimeout(function() {
                    // 处理完成，显示结果 - 不传参数，函数内部已经使用window.sensorData
                    detectAnomalies();
                }, 1500); // 模拟处理时间
            } catch (error) {
                console.error('启动异常检测时出错:', error);
                alert('启动异常检测过程中出错: ' + error.message);
            }
        }
        
        // 异常检测算法 - 使用DBSCAN方法
        function detectAnomalies() {
            try {
                // 检查是否有数据
                if (!window.sensorData || window.sensorData.length === 0) {
                    alert('没有数据可供分析。请先上传数据。');
                    return;
                }
                
                // 显示分析加载动画
                if (analysisLoader) analysisLoader.style.display = 'block';
                if (noAnalysisMessage) noAnalysisMessage.style.display = 'none';
                if (analysisSummary) analysisSummary.style.display = 'none';
                
                // 显示分析内容区域
                const analysisContent = document.getElementById('analysis-content');
                if (analysisContent) {
                    analysisContent.style.display = 'block';
                }
                
                // 显示图表区域
                const anomalyChartSection = document.getElementById('anomaly-chart-section');
                if (anomalyChartSection) {
                    anomalyChartSection.style.display = 'block';
                }
                
                console.log('开始DBSCAN异常检测...');
                console.log(`数据点总数: ${window.sensorData.length}`);
                
                // 按传感器ID分组数据
                const sensorGroups = {};
                
                window.sensorData.forEach(dataPoint => {
                    if (!sensorGroups[dataPoint.sensorId]) {
                        sensorGroups[dataPoint.sensorId] = {
                            type: dataPoint.sensorType,
                            values: [],
                            timestamps: [],
                            anomalies: []
                        };
                    }
                    
                    sensorGroups[dataPoint.sensorId].values.push(dataPoint.value);
                    sensorGroups[dataPoint.sensorId].timestamps.push(dataPoint.timestamp);
                });
                
                // 使用setTimeout在下一个事件循环执行DBSCAN，避免UI阻塞
                setTimeout(() => {
                    try {
                let totalAnomalies = 0;
                let sensorAnomalyCount = 0;
                
                        // 遍历每个传感器组应用DBSCAN
                Object.keys(sensorGroups).forEach(sensorId => {
                    const group = sensorGroups[sensorId];
                    const values = group.values;
                    
                            // 应用DBScan方法检测异常
                            const anomalyIndices = DBScan(values);
                            
                            // 如果有异常，标记并计数
                            if (anomalyIndices && anomalyIndices.length > 0) {
                    let hasAnomaly = false;
                                
                                anomalyIndices.forEach(index => {
                                    // 确保索引在有效范围内
                                    if (index >= 0 && index < values.length) {
                                        // 计算异常类型
                                        const anomalyType = determineAnomalyType(index, values, 3.0); // 使用默认值3.0作为分类依据
                            
                            group.anomalies.push({
                                index: index,
                                            value: values[index],
                                timestamp: group.timestamps[index],
                                            score: 0,  // DBSCAN不计算分数，保留为兼容性
                                            type: anomalyType || '未分类异常'
                            });
                            
                            hasAnomaly = true;
                            totalAnomalies++;
                        }
                    });
                    
                    if (hasAnomaly) {
                        sensorAnomalyCount++;
                                }
                    }
                });
                
                // 显示结果和创建图表
                displayAnomalyResults(sensorGroups, totalAnomalies, sensorAnomalyCount);
                
                // 隐藏加载动画
                if (analysisLoader) analysisLoader.style.display = 'none';
                
                        console.log(`DBSCAN检测完成，发现 ${totalAnomalies} 个异常点，涉及 ${sensorAnomalyCount} 个传感器`);
                        
                        // 保存结果
                        window.anomalies = {
                            sensorGroups,
                            totalAnomalies,
                            sensorCount: sensorAnomalyCount
                        };
                        
                        // 更新修复控制
                        updateRepairControls(sensorGroups);
                        
                        // 添加到历史记录
                        addToHistory(sensorGroups, totalAnomalies, sensorAnomalyCount);
            } catch (error) {
                        console.error('DBSCAN检测异常时出错:', error);
                alert('检测异常时出错: ' + error.message);
                if (analysisLoader) analysisLoader.style.display = 'none';
                    }
                }, 10); // 短暂延迟，让UI可以刷新
                
            } catch (error) {
                console.error('DBSCAN检测异常时出错:', error);
                alert('检测异常时出错: ' + error.message);
                if (analysisLoader) analysisLoader.style.display = 'none';
            }
        }
        
        // DBScan算法实现 - 用于检测异常值（优化版本）
        function DBScan(data) {
            try {
                console.log("开始DBSCAN异常检测...");
                console.log("数据点总数:", data.length);
                
                // 数据检查
                if (!data || data.length === 0) {
                    console.log("没有数据可供检测");
                    return [];
                }
                
                // 限制最大处理数据量，避免浏览器卡死
                const MAX_POINTS = 1000;
                let sampledData = data;
                
                if (data.length > MAX_POINTS) {
                    console.log(`数据点过多(${data.length})，进行降采样处理...`);
                    // 均匀采样
                    const step = Math.ceil(data.length / MAX_POINTS);
                    sampledData = [];
                    for (let i = 0; i < data.length; i += step) {
                        sampledData.push(data[i]);
                    }
                    console.log(`降采样后数据点数量: ${sampledData.length}`);
                }
                
                // 转换为数值数组并排序
                const values = sampledData.map(v => {
                    if (v === undefined || v === null) return 0;
                    return typeof v === 'string' ? parseFloat(v) : v;
                }).sort((a, b) => a - b);
                
                // 计算直方图和非零间距（优化：使用标准统计方法）
                const diffs = [];
                for (let i = 1; i < values.length; i++) {
                    const diff = Math.abs(values[i] - values[i-1]);
                    if (diff > 0) diffs.push(diff);
                }
                
                if (diffs.length === 0) {
                    console.log("所有数据点的值都相同，无法计算间距");
                    return [];
                }
                
                // 计算中位数差异作为epsilon参数（比平均值更稳健）
                diffs.sort((a, b) => a - b);
                const medianDiff = diffs[Math.floor(diffs.length / 2)];
                // 使用IQR方法设置epsilon (四分位距方法)
                const q1 = diffs[Math.floor(diffs.length / 4)];
                const q3 = diffs[Math.floor(3 * diffs.length / 4)];
                const iqr = q3 - q1;
                
                // 使用统计学上更合理的阈值
                const epsilon = medianDiff + 1.5 * iqr;
                
                console.log("计算得到的DBSCAN参数: epsilon =", epsilon);
                
                // 应用改进版DBSCAN聚类（使用空间优化）
                const minPts = 2; // 最小点数，小于此值的聚类被视为噪声
                let labels = new Array(values.length).fill(-1); // -1 表示未分类
                let clusterIdx = 0;
                
                // 优化：使用邻接矩阵存储邻居关系，避免重复计算
                const neighbors = [];
                for (let i = 0; i < values.length; i++) {
                    neighbors[i] = [];
                    for (let j = 0; j < values.length; j++) {
                        if (Math.abs(values[i] - values[j]) <= epsilon) {
                            neighbors[i].push(j);
                        }
                    }
                }
                
                // 优化：扩展簇的递归替代方案
                function expandCluster(pointIdx, clusterIdx) {
                    const queue = [...neighbors[pointIdx]];
                    
                    while (queue.length > 0) {
                        const current = queue.shift();
                        
                        // 如果点未分类
                        if (labels[current] === -1) {
                            labels[current] = clusterIdx;
                            
                            // 如果是核心点，将其邻居加入队列
                            if (neighbors[current].length >= minPts) {
                                for (const n of neighbors[current]) {
                                    if (labels[n] === -1) {
                                        queue.push(n);
                                    }
                                }
                            }
                        }
                    }
                }
                
                // 开始聚类
                for (let i = 0; i < values.length; i++) {
                    // 跳过已分类的点
                    if (labels[i] !== -1) continue;
                    
                    // 如果是核心点，创建新簇
                    if (neighbors[i].length >= minPts) {
                        labels[i] = clusterIdx;
                        expandCluster(i, clusterIdx);
                        clusterIdx++;
                    }
                }
                
                console.log(`DBSCAN聚类完成，找到 ${clusterIdx} 个聚类`);
                
                // 收集异常点（未分类的点为异常）
                const anomalies = [];
                for (let i = 0; i < labels.length; i++) {
                    if (labels[i] === -1) {
                        anomalies.push(i);
                    }
                }
                
                // 检查最小簇，小簇也视为异常（阈值为总数据量的1%）
                const clusterSizes = new Array(clusterIdx).fill(0);
                for (let i = 0; i < labels.length; i++) {
                    if (labels[i] >= 0) {
                        clusterSizes[labels[i]]++;
                    }
                }
                
                const smallClusterThreshold = Math.max(3, Math.ceil(values.length * 0.01));
                for (let i = 0; i < labels.length; i++) {
                    if (labels[i] >= 0 && clusterSizes[labels[i]] < smallClusterThreshold) {
                        anomalies.push(i);
                    }
                }
                
                // 去重
                const uniqueAnomalies = [...new Set(anomalies)];
                
                // 查找数据中的原始索引（优化：使用Map减少查找）
                const valueToIndexMap = new Map();
                for (let i = 0; i < sampledData.length; i++) {
                    const numV = (sampledData[i] === undefined || sampledData[i] === null) ? 0 : 
                               (typeof sampledData[i] === 'string' ? parseFloat(sampledData[i]) : sampledData[i]);
                    valueToIndexMap.set(numV.toFixed(5), i);
                }
                
                const originalIndices = [];
                for (const anomalyIndex of uniqueAnomalies) {
                    if (anomalyIndex >= 0 && anomalyIndex < values.length) {
                        const anomalyValue = values[anomalyIndex];
                        const key = anomalyValue.toFixed(5);
                        
                        if (valueToIndexMap.has(key)) {
                            originalIndices.push(valueToIndexMap.get(key));
                        }
                    }
                }
                
                console.log(`DBSCAN检测完成，发现 ${uniqueAnomalies.length} 个异常点，匹配到 ${originalIndices.length} 个索引`);
                
                // 发现异常时尝试更新修复控件
                if (originalIndices.length > 0) {
                    try {
                        // 这里不直接调用updateRepairControls，因为它会在主函数detectAnomalies中调用
                        // 避免重复调用导致界面混乱
                        console.log("发现异常点，稍后将更新修复控件");
                    } catch (err) {
                        console.error("准备更新修复控件时出错:", err);
                    }
                }
                
                return originalIndices;
            } catch (error) {
                console.error("DBSCAN异常检测时出错:", error);
                return []; // 检测出错时返回空数组，表示没有异常
            }
        }
        
        // 显示异常结果
        function displayAnomalyResults(sensorGroups, totalAnomalies, sensorAnomalyCount) {
            try {
                // 隐藏加载和无数据提示 - 始终隐藏无数据消息
                if (analysisLoader) analysisLoader.style.display = 'none';
                
                const noAnalysisMessage = document.getElementById('no-analysis-message');
                if (noAnalysisMessage) noAnalysisMessage.style.display = 'none';
                
                // 显示结果摘要
                if (analysisSummary) {
                    analysisSummary.style.display = 'block';
                    analysisSummary.innerHTML = `
                        <div class="alert-compact alert-info">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <h5 style="margin: 0; font-size: 16px;">异常检测完成</h5>
                                <span style="font-size: 14px;">${new Date().toLocaleString()}</span>
                            </div>
                            <div style="display: flex; flex-wrap: wrap; gap: 15px; margin-top: 10px;">
                                <div style="flex: 1; min-width: 120px;">
                                    <div style="font-size: 13px; color: #4a5568;">数据点数量</div>
                                    <div style="font-size: 18px; font-weight: bold; color: #2c5282;">${window.sensorData.length}</div>
                                </div>
                                <div style="flex: 1; min-width: 120px;">
                                    <div style="font-size: 13px; color: #4a5568;">异常点数量</div>
                                    <div style="font-size: 18px; font-weight: bold; color: #c05621;">${totalAnomalies}</div>
                                </div>
                                <div style="flex: 1; min-width: 120px;">
                                    <div style="font-size: 13px; color: #4a5568;">异常传感器数</div>
                                    <div style="font-size: 18px; font-weight: bold; color: #2c5282;">${sensorAnomalyCount}</div>
                                </div>
                                <div style="flex: 1; min-width: 120px;">
                                    <div style="font-size: 13px; color: #4a5568;">异常率</div>
                                    <div style="font-size: 18px; font-weight: bold; color: ${(totalAnomalies/window.sensorData.length) > 0.05 ? '#c53030' : '#2c5282'};">
                                        ${(totalAnomalies/window.sensorData.length*100).toFixed(2)}%
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;
                }
                
                // 过滤异常类型
                const anomalyTypeFilter = document.getElementById('anomaly-type-filter');
                let typeFilter = 'all';
                if (anomalyTypeFilter) {
                    typeFilter = anomalyTypeFilter.value;
                }
                
                // 显示异常列表
                const anomalyListElement = document.getElementById('anomaly-list');
                if (!anomalyListElement) {
                    console.error('未找到异常列表元素(#anomaly-list)');
                    return;
                }
                
                // 清空列表内容
                anomalyListElement.innerHTML = '';
                
                // 计数器
                let displayedAnomalies = 0;
                
                // 遍历每个传感器的异常
                Object.keys(sensorGroups).forEach(sensorId => {
                    const group = sensorGroups[sensorId];
                    
                    // 过滤显示的异常类型
                    const anomalies = group.anomalies.filter(anomaly => {
                        return typeFilter === 'all' || anomaly.type === typeFilter;
                    });
                    
                    if (anomalies.length === 0) return;
                    
                    // 添加传感器标题
                    const sensorHeader = document.createElement('div');
                    sensorHeader.className = 'anomaly-sensor-header';
                    sensorHeader.innerHTML = `<h5>${sensorId} <span style="color: #718096; font-size: 13px;">(${anomalies.length} 个异常)</span></h5>`;
                    anomalyListElement.appendChild(sensorHeader);
                    
                    // 添加每个异常项
                    anomalies.forEach(anomaly => {
                        const anomalyItem = document.createElement('div');
                        anomalyItem.className = 'anomaly-item';
                        
                        // 所有DBSCAN检测的异常都标记为严重
                            anomalyItem.classList.add('severe');
                        
                        anomalyItem.innerHTML = `
                            <div class="anomaly-info">
                                <div class="anomaly-time">${anomaly.timestamp}</div>
                                <div class="anomaly-value">值: <b>${anomaly.value}</b></div>
                                <div class="anomaly-type">${anomaly.type}</div>
                            </div>
                        `;
                        
                        anomalyListElement.appendChild(anomalyItem);
                        displayedAnomalies++;
                    });
                });
                
                // 如果没有异常，显示提示，但保持图表显示
                if (displayedAnomalies === 0) {
                    const noAnomalies = document.createElement('div');
                    noAnomalies.className = 'no-anomalies-message';
                    noAnomalies.style.padding = '20px';
                    noAnomalies.textContent = totalAnomalies > 0 ? 
                        '当前筛选条件下没有异常点可显示' : 
                        '未检测到任何异常点，所有数据均在正常范围内';
                    anomalyListElement.appendChild(noAnomalies);
                }
                
                // 始终创建或更新异常图表，即使没有异常
                createAnomalyChart(sensorGroups);
                
                // 添加到历史记录
                addToHistory(sensorGroups, totalAnomalies, sensorAnomalyCount);
            } catch (error) {
                console.error('显示异常结果时出错:', error);
            }
        }
        
        // 创建异常图表
        function createAnomalyChart(sensorGroups) {
            try {
                // 查找异常图表容器
                const chartContainer = document.getElementById('anomaly-chart-container');
                if (!chartContainer) {
                    console.error('未找到异常图表容器');
                    return;
                }
                
                // 清空容器
                chartContainer.innerHTML = '';
                
                // 检查是否有数据
                if (!sensorGroups || Object.keys(sensorGroups).length === 0) {
                    chartContainer.innerHTML = '<div class="no-anomalies-message">没有数据可供图表显示</div>';
                    return;
                }
                
                // 按传感器类型分组传感器
                const sensorsByType = {};
                
                // 分组传感器
                Object.keys(sensorGroups).forEach(sensorId => {
                    const group = sensorGroups[sensorId];
                    const sensorType = getSensorTypeFromId(sensorId, group.type);
                    
                    if (!sensorsByType[sensorType]) {
                        sensorsByType[sensorType] = {};
                    }
                    
                    sensorsByType[sensorType][sensorId] = group;
                });
                
                // 颜色映射
                const colors = [
                    '#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', 
                    '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', 
                    '#bcbd22', '#17becf'
                ];
                
                // 为每个传感器类型创建数据集
                Object.keys(sensorsByType).forEach((sensorType, typeIndex) => {
                    // 创建传感器类型标题
                    const typeHeader = document.createElement('h3');
                    typeHeader.className = 'sensor-type-header';
                    typeHeader.textContent = `${sensorType}传感器数据`;
                    typeHeader.style.marginTop = '20px';
                    typeHeader.style.color = '#2c5282';
                    chartContainer.appendChild(typeHeader);
                    
                    // 创建图表容器
                    const chartDiv = document.createElement('div');
                    chartDiv.className = 'chart-wrapper';
                    chartDiv.style.height = '300px';
                    chartDiv.style.marginBottom = '20px';
                    chartContainer.appendChild(chartDiv);
                    
                    // 创建Canvas元素
                    const canvas = document.createElement('canvas');
                    canvas.id = `chart-${sensorType.replace(/[^a-zA-Z0-9]/g, '-')}`;
                    chartDiv.appendChild(canvas);
                    
                    // 准备数据集
                    const datasets = [];
                    let sensorIndex = 0;
                    
                    Object.keys(sensorsByType[sensorType]).forEach(sensorId => {
                        const group = sensorsByType[sensorType][sensorId];
                        
                        // 创建数据点数组
                        const dataPoints = group.values.map((value, index) => ({
                            x: group.timestamps[index],
                            y: parseFloat(value),
                            status: group.anomalies.some(anomaly => anomaly.index === index) ? 'danger' : 'normal'
                        }));
                        
                        // 对数据按时间排序
                        dataPoints.sort((a, b) => new Date(a.x) - new Date(b.x));
                        
                        // 取最后25个点以避免过度拥挤
                        const points = dataPoints.slice(-25);
                        
                        // 添加原始数据线
                    datasets.push({
                        label: sensorId,
                            data: points,
                            borderColor: colors[sensorIndex % colors.length],
                            backgroundColor: colors[sensorIndex % colors.length] + '20',
                            pointRadius: 4,
                            pointHoverRadius: 6,
                            pointBackgroundColor: function(context) {
                                const point = context.dataset.data[context.dataIndex];
                                if (point.status === 'danger' || point.status === 'alarm') {
                                    return '#dc3545';
                                } else if (point.status === 'warning') {
                                    return '#ffc107';
                                }
                                return colors[sensorIndex % colors.length];
                            },
                            pointBorderColor: '#fff',
                            pointBorderWidth: 1.5,
                            tension: 0.2
                        });

                        // 添加异常点数据集 - 使异常点更加明显
                        const anomalyPoints = points.filter(point => point.status === 'danger');
                        if (anomalyPoints.length > 0) {
                            datasets.push({
                                label: `${sensorId} - 异常点`,
                                data: anomalyPoints,
                                borderColor: '#dc3545',
                                borderWidth: 3,
                                backgroundColor: 'rgba(255, 0, 0, 0.7)',
                                pointRadius: 10,
                                pointHoverRadius: 14,
                                pointStyle: 'rectRot',  // 使用矩形旋转，更明显
                                pointBorderWidth: 2,
                                pointBorderColor: '#fff',
                                showLine: false
                            });
                            
                            // 添加一个额外的高亮环
                        datasets.push({
                                label: `${sensorId} - 异常点标记`,
                                data: anomalyPoints,
                            borderColor: 'transparent',
                                backgroundColor: 'rgba(255, 0, 0, 0.2)',
                                pointRadius: 16,
                                pointHoverRadius: 20,
                                pointStyle: 'circle',
                            showLine: false
                        });
                    }
                        
                        sensorIndex++;
                    });
                
                // 创建图表
                    new Chart(canvas, {
                    type: 'line',
                    data: {
                        datasets: datasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: {
                                type: 'category',
                                title: {
                                    display: true,
                                    text: '时间'
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                        text: `${sensorType}值`
                                }
                            }
                        },
                        plugins: {
                                title: {
                                    display: true,
                                    text: `${sensorType}传感器数据可视化`,
                                    font: {
                                        size: 16,
                                        weight: 'bold'
                                    }
                                },
                            legend: {
                                position: 'top',
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const point = context.dataset.data[context.dataIndex];
                                            let status = '正常';
                                            if (point.status === 'warning') status = '警告';
                                            if (point.status === 'danger' || point.status === 'alarm') status = '危险';
                                            return `${context.dataset.label}: ${point.y} (${status})`;
                                    }
                                }
                            }
                        }
                    }
                });
                
                    console.log(`已创建 ${sensorType} 类型传感器的图表，包含 ${datasets.length} 个传感器`);
                });
                
            } catch (error) {
                console.error('创建异常图表时出错:', error);
            }
        }
        
        // 添加到历史记录
        function addToHistory(sensorGroups, totalAnomalies, sensorAnomalyCount) {
            try {
                // 创建历史记录条目
                const historyEntry = {
                    id: Date.now(),
                    timestamp: new Date().toLocaleString(),
                    anomalyCount: totalAnomalies,
                    sensorCount: sensorAnomalyCount,
                    dataPoints: window.sensorData.length,
                    sensorGroups: sensorGroups
                };
                
                // 将历史记录保存到本地存储
                let historyData = JSON.parse(localStorage.getItem('anomalyHistory') || '[]');
                historyData.push(historyEntry);
                localStorage.setItem('anomalyHistory', JSON.stringify(historyData));
                
                // 更新历史记录显示
                updateHistoryList();
            } catch (error) {
                console.error('添加历史记录时出错:', error);
            }
        }
        
        // 更新历史记录列表
        function updateHistoryList() {
            try {
                // 查找历史记录列表容器
                const historyList = document.getElementById('history-list');
                if (!historyList) return;
                
                // 从本地存储获取历史记录
                let historyData = JSON.parse(localStorage.getItem('anomalyHistory') || '[]');
                
                // 清空当前列表
                historyList.innerHTML = '';
                
                // 如果没有历史记录，显示提示
                if (historyData.length === 0) {
                    historyList.innerHTML = '<div class="no-history">暂无历史记录</div>';
                    return;
                }
                
                // 按时间倒序排列
                historyData.sort((a, b) => b.id - a.id);
                
                // 显示历史记录
                historyData.forEach(entry => {
                    const historyItem = document.createElement('div');
                    historyItem.className = 'history-item';
                    historyItem.dataset.id = entry.id;
                    
                    // 计算严重程度
                    let severityClass = 'normal';
                    const anomalyRate = entry.anomalyCount / entry.dataPoints;
                    if (anomalyRate > 0.05) {
                        severityClass = 'critical';
                    } else if (anomalyRate > 0.02) {
                        severityClass = 'warning';
                    }
                    
                    historyItem.innerHTML = `
                        <div class="history-header">
                            <div class="history-time">${entry.timestamp}</div>
                            <div class="history-stats ${severityClass}">
                                ${entry.anomalyCount} 异常 / ${entry.dataPoints} 数据点
                            </div>
                        </div>
                        <div class="history-actions">
                            <button class="history-view-btn" data-id="${entry.id}">查看详情</button>
                            <button class="history-delete-btn" data-id="${entry.id}">删除</button>
                        </div>
                    `;
                    
                    historyList.appendChild(historyItem);
                    
                    // 添加查看按钮事件
                    const viewBtn = historyItem.querySelector('.history-view-btn');
                    viewBtn.addEventListener('click', function() {
                        viewHistoryItem(entry.id);
                    });
                    
                    // 添加删除按钮事件
                    const deleteBtn = historyItem.querySelector('.history-delete-btn');
                    deleteBtn.addEventListener('click', function() {
                        deleteHistoryItem(entry.id);
                    });
                });
            } catch (error) {
                console.error('更新历史记录列表时出错:', error);
            }
        }
        
        // 查看历史记录项
        function viewHistoryItem(id) {
            try {
                // 从本地存储获取历史记录
                let historyData = JSON.parse(localStorage.getItem('anomalyHistory') || '[]');
                
                // 查找对应的历史记录
                const entry = historyData.find(item => item.id === id);
                if (!entry) {
                    console.error('未找到历史记录:', id);
                    return;
                }
                
                // 显示历史记录详情
                displayAnomalyResults(entry.sensorGroups, entry.anomalyCount, entry.sensorCount);
                
                // 创建历史记录图表
                createAnomalyChart(entry.sensorGroups);
                
                // 切换到分析标签
                const analysisTab = document.querySelector('.tab[data-tab="analysis"]');
                if (analysisTab) {
                    analysisTab.click();
                }
            } catch (error) {
                console.error('查看历史记录时出错:', error);
            }
        }
        
        // 删除历史记录项
        function deleteHistoryItem(id) {
            try {
                // 确认删除
                if (!confirm('确定要删除此历史记录吗？')) {
                    return;
                }
                
                // 从本地存储获取历史记录
                let historyData = JSON.parse(localStorage.getItem('anomalyHistory') || '[]');
                
                // 过滤掉要删除的项
                historyData = historyData.filter(item => item.id !== id);
                
                // 保存更新后的历史记录
                localStorage.setItem('anomalyHistory', JSON.stringify(historyData));
                
                // 更新历史记录显示
                updateHistoryList();
            } catch (error) {
                console.error('删除历史记录时出错:', error);
            }
        }

        // 添加清空历史记录函数
        function clearAllHistory() {
            try {
                if (confirm('确定要清空所有历史记录吗？此操作不可恢复。')) {
                    localStorage.removeItem('anomalyHistory');
                    updateHistoryList();
                }
            } catch (error) {
                console.error('清空历史记录时出错:', error);
            }
        }

        // 更新数据修复控制区域
        function updateRepairControls(sensorGroups) {
            try {
                // 获取控制区域元素
                const repairControl = document.getElementById('repair-control');
                const noRepairMessage = document.getElementById('no-repair-message');
                const sensorSelect = document.getElementById('repair-sensor-select');
                
                if (!repairControl || !sensorSelect) return;
                
                // 显示控制区域
                if (repairControl) repairControl.style.display = 'block';
                if (noRepairMessage) noRepairMessage.style.display = 'none';
                
                // 更新传感器选择下拉菜单
                updateSensorSelectForNextRepair(sensorGroups);
                
                // 绑定开始修复按钮事件
                const startRepairBtn = document.getElementById('start-repair-btn');
                if (startRepairBtn) {
                    // 移除旧事件监听器，避免重复绑定
                    const newBtn = startRepairBtn.cloneNode(true);
                    startRepairBtn.parentNode.replaceChild(newBtn, startRepairBtn);
                    
                    newBtn.addEventListener('click', function() {
                        startDataRepair();
                    });
                }
                
                // 更新修复区域标题
                const repairHeader = document.querySelector('.repair-header h3');
                if (repairHeader) {
                    repairHeader.textContent = '选择需要修复的传感器';
                }
            } catch (error) {
                console.error('更新数据修复控制区域时出错:', error);
            }
        }
        
        // 开始数据修复
        function startDataRepair() {
            try {
                // 获取选中的传感器ID
                const sensorSelect = document.getElementById('repair-sensor-select');
                const modelSelect = document.getElementById('repair-model-select');
                
                if (!sensorSelect || !modelSelect) return;
                
                const sensorId = sensorSelect.value;
                const modelType = modelSelect.value;
                
                if (!sensorId) {
                    alert('请选择需要修复的传感器!');
                    return;
                }
                
                // 显示加载动画
                const repairLoader = document.getElementById('repair-loader');
                const repairContent = document.getElementById('repair-content');
                const repairControl = document.getElementById('repair-control');
                
                if (repairLoader) repairLoader.style.display = 'block';
                if (repairContent) repairContent.style.display = 'none';
                if (repairControl) repairControl.style.display = 'none';
                
                // 模拟LSTM模型加载和处理时间
                setTimeout(function() {
                    // 使用LSTM模型修复数据
                    if (modelType === 'lstm') {
                        repairDataWithLSTM(sensorId);
                    } else {
                        alert('暂不支持其他修复模型!');
                        
                        if (repairLoader) repairLoader.style.display = 'none';
                        if (repairControl) repairControl.style.display = 'block';
                    }
                }, 1500);
            } catch (error) {
                console.error('启动数据修复时出错:', error);
                alert('启动数据修复过程中出错: ' + error.message);
                
                const repairLoader = document.getElementById('repair-loader');
                const repairControl = document.getElementById('repair-control');
                
                if (repairLoader) repairLoader.style.display = 'none';
                if (repairControl) repairControl.style.display = 'block';
            }
        }
        
        // 使用LSTM模型修复数据
        function repairDataWithLSTM(sensorId) {
            try {
                console.log(`使用LSTM修复传感器 ${sensorId} 的数据`);
                
                // 获取该传感器的数据
                const sensorData = window.sensorData.filter(item => item.sensorId === sensorId);
                
                if (!sensorData || sensorData.length === 0) {
                    throw new Error('未找到传感器数据!');
                }
                
                // 获取异常数据索引
                const anomalySensorGroups = getAnomalySensorGroups();
                if (!anomalySensorGroups || !anomalySensorGroups[sensorId]) {
                    throw new Error('未找到传感器异常信息!');
                }
                
                const anomalies = anomalySensorGroups[sensorId].anomalies;
                
                if (!anomalies || anomalies.length === 0) {
                    throw new Error('该传感器没有异常数据需要修复!');
                }
                
                // 使用LSTM模型预测异常点的修复值
                const repairedData = simulateLSTMPrediction(sensorData, anomalies);
                
                // 显示修复结果
                displayRepairResults(sensorId, sensorData, repairedData);
                
            } catch (error) {
                console.error('LSTM数据修复时出错:', error);
                alert('数据修复时出错: ' + error.message);
                
                const repairLoader = document.getElementById('repair-loader');
                const repairControl = document.getElementById('repair-control');
                
                if (repairLoader) repairLoader.style.display = 'none';
                if (repairControl) repairControl.style.display = 'block';
            }
        }
        
        // 模拟LSTM预测 - 实际项目中应加载和使用真实的预训练模型
        function simulateLSTMPrediction(sensorData, anomalies) {
            try {
                // 排序数据，确保按时间顺序
                sensorData.sort((a, b) => {
                    return new Date(a.timestamp) - new Date(b.timestamp);
                });
                
                // 提取数值序列
                const values = sensorData.map(item => parseFloat(item.value));
                
                // 创建修复结果数组
                const repaired = [];
                
                // 对每个异常点进行预测修复
                anomalies.forEach(anomaly => {
                    const index = anomaly.index;
                    
                    // 确保索引有效
                    if (index >= 0 && index < values.length) {
                        // 获取异常点的相关信息
                        const originalValue = values[index];
                        const timestamp = sensorData[index].timestamp;
                        const sensorId = sensorData[index].sensorId;
                        
                        // 获取前10个数据点作为模型输入（如果不足则使用全部）
                        const sequenceLength = 10;
                        const startIndex = Math.max(0, index - sequenceLength);
                        const sequence = values.slice(startIndex, index);
                        
                        // 模拟LSTM预测 - 在实际应用中，这里应该调用真实的模型
                        // 这里简单使用前5个点的平均值作为修复值的替代方案
                        let predictedValue;
                        
                        if (sequence.length > 0) {
                            const sum = sequence.reduce((acc, val) => acc + val, 0);
                            predictedValue = sum / sequence.length;
                            
                            // 添加一些随机波动以模拟真实预测
                            const randomFactor = 0.9 + Math.random() * 0.2; // 0.9到1.1之间
                            predictedValue *= randomFactor;
                        } else {
                            // 如果没有前序数据，使用平均值估计
                            const valuesSum = values.reduce((acc, val) => acc + val, 0);
                            predictedValue = valuesSum / values.length;
                        }
                        
                        // 添加到修复结果
                        repaired.push({
                            index: index,
                            sensorId: sensorId,
                            timestamp: timestamp,
                            originalValue: originalValue,
                            repairedValue: predictedValue.toFixed(2),
                        });
                    }
                });
                
                return repaired;
            } catch (error) {
                console.error('LSTM预测时出错:', error);
                throw error;
            }
        }
        
        // 显示修复结果
        function displayRepairResults(sensorId, originalData, repairedData) {
            try {
                console.log(`显示传感器 ${sensorId} 的修复结果`);
                
                // 获取UI元素
                const repairLoader = document.getElementById('repair-loader');
                const repairContent = document.getElementById('repair-content');
                const repairTable = document.getElementById('repair-table').querySelector('tbody');
                const repairTimestamp = document.getElementById('repair-timestamp');
                const repairStats = document.getElementById('repair-stats');
                
                // 隐藏加载，显示结果
                if (repairLoader) repairLoader.style.display = 'none';
                if (repairContent) repairContent.style.display = 'block';
                
                // 更新时间戳
                if (repairTimestamp) {
                    repairTimestamp.textContent = new Date().toLocaleString();
                }
                
                // 更新统计信息
                if (repairStats) {
                    repairStats.innerHTML = `
                        <div style="display: flex; flex-wrap: wrap; gap: 15px;">
                            <div style="flex: 1; min-width: 120px;">
                                <div style="font-size: 13px; color: #4a5568;">传感器</div>
                                <div style="font-size: 18px; font-weight: bold; color: #2c5282;">${sensorId}</div>
                            </div>
                            <div style="flex: 1; min-width: 120px;">
                                <div style="font-size: 13px; color: #4a5568;">修复点数量</div>
                                <div style="font-size: 18px; font-weight: bold; color: #c05621;">${repairedData.length}</div>
                            </div>
                            <div style="flex: 1; min-width: 120px;">
                                <div style="font-size: 13px; color: #4a5568;">修复模型</div>
                                <div style="font-size: 18px; font-weight: bold; color: #2c5282;">LSTM</div>
                            </div>
                        </div>
                    `;
                }
                
                // 清空表格
                if (repairTable) {
                    repairTable.innerHTML = '';
                
                    // 填充表格数据
                    repairedData.forEach(item => {
                        const row = document.createElement('tr');
                        
                        // 设置行样式
                        row.className = 'repaired-row';
                        
                        // 设置单元格内容
                        row.innerHTML = `
                            <td>${item.timestamp}</td>
                            <td>${item.sensorId}</td>
                            <td style="color: #c53030; font-weight: bold;">${item.originalValue}</td>
                            <td style="color: #2c5282; font-weight: bold;">${item.repairedValue}</td>
                            <td><span class="status-badge status-normal">已修复</span></td>
                        `;
                        
                        repairTable.appendChild(row);
                    });
                }
                
                // 创建对比图表
                createRepairChart(sensorId, originalData, repairedData);
                
                // 设置应用修复和导出按钮事件，以及新增的继续修复按钮事件
                setupRepairButtons(sensorId, repairedData);
                
            } catch (error) {
                console.error('显示修复结果时出错:', error);
                alert('显示修复结果时出错: ' + error.message);
                
                const repairLoader = document.getElementById('repair-loader');
                const repairControl = document.getElementById('repair-control');
                
                if (repairLoader) repairLoader.style.display = 'none';
                if (repairControl) repairControl.style.display = 'block';
            }
        }
        
        // 创建修复对比图表
        function createRepairChart(sensorId, originalData, repairedData) {
            try {
                // 查找图表容器
                const chartCanvas = document.getElementById('repair-chart');
                if (!chartCanvas) {
                    console.error('未找到修复图表容器');
                    return;
                }
                
                // 如果已有图表，先销毁
                if (window.repairChart) {
                    try {
                        // 检查Chart.js实例是否存在并有destroy方法
                        if (window.repairChart && typeof window.repairChart.destroy === 'function') {
                            window.repairChart.destroy();
                        } else {
                            console.log('Chart没有destroy方法，尝试其他方式清除');
                            // 手动清除Canvas
                            const ctx = chartCanvas.getContext('2d');
                            if (ctx) {
                                ctx.clearRect(0, 0, chartCanvas.width, chartCanvas.height);
                            }
                            // 重置Chart对象
                            window.repairChart = null;
                        }
                    } catch (error) {
                        console.error('销毁修复图表时出错:', error);
                        window.repairChart = null;
                    }
                }
                
                // 准备图表数据
                const timestamps = originalData.map(item => item.timestamp);
                const values = originalData.map(item => parseFloat(item.value));
                
                // 创建修复数据点
                const repairedPoints = repairedData.map(item => ({
                    x: item.timestamp,
                    y: parseFloat(item.repairedValue)
                }));
                
                // 创建异常点标记
                const anomalyPoints = repairedData.map(item => ({
                    x: item.timestamp,
                    y: parseFloat(item.originalValue)
                }));
                
                // 创建图表数据集
                const datasets = [
                    {
                        label: '原始数据',
                        data: timestamps.map((time, index) => ({ x: time, y: values[index] })),
                        borderColor: '#3182ce',
                        backgroundColor: 'transparent',
                        borderWidth: 2,
                        pointRadius: 0,
                        pointHoverRadius: 3,
                        pointBackgroundColor: '#3182ce',
                        pointBorderColor: '#fff',
                        pointBorderWidth: 1.5,
                        tension: 0.2
                    },
                    {
                        label: '异常点',
                        data: anomalyPoints,
                        borderColor: 'transparent',
                        backgroundColor: '#e53e3e',
                        borderWidth: 0,
                        pointRadius: 6,
                        pointHoverRadius: 8,
                        pointStyle: 'circle',
                        pointBackgroundColor: '#e53e3e',
                        pointBorderColor: '#fff',
                        pointBorderWidth: 1.5,
                        showLine: false
                    },
                    {
                        label: '修复值',
                        data: repairedPoints,
                        borderColor: '#10b981',
                        backgroundColor: 'transparent',
                        borderWidth: 0,
                        pointRadius: 6,
                        pointHoverRadius: 8,
                        pointStyle: 'rectRot',
                        pointBackgroundColor: '#10b981',
                        pointBorderColor: '#fff',
                        pointBorderWidth: 1.5,
                        showLine: false
                    }
                ];
                
                // 创建图表
                window.repairChart = new Chart(chartCanvas, {
                    type: 'line',
                    data: { datasets },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: {
                                type: 'category',
                                title: {
                                    display: true,
                                    text: '时间'
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: '数值'
                                }
                            }
                        },
                        plugins: {
                            legend: {
                                position: 'top',
                            },
                            title: {
                                display: true,
                                text: `传感器 ${sensorId} 数据修复`,
                                font: {
                                    size: 16
                                }
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        try {
                                            const datasetLabel = context.dataset.label || '';
                                            let value = '';
                                            
                                            // 安全地获取y值
                                            if (context.parsed && context.parsed.y !== undefined) {
                                                value = context.parsed.y;
                                            } else if (context.raw && context.raw.y !== undefined) {
                                                value = context.raw.y;
                                            }
                                            
                                            return `${datasetLabel}: ${value}`;
                                        } catch (error) {
                                            console.error("绘制tooltip时出错:", error);
                                            return '数据加载中...';
                                        }
                                    }
                                }
                            }
                        }
                    }
                });
                
                console.log('修复对比图表已创建');
            } catch (error) {
                console.error('创建修复图表时出错:', error);
            }
        }
        
        // 设置修复相关按钮事件
        function setupRepairButtons(sensorId, repairedData) {
            try {
                // 应用修复按钮
                const applyBtn = document.getElementById('apply-repair-btn');
                if (applyBtn) {
                    const newBtn = applyBtn.cloneNode(true);
                    applyBtn.parentNode.replaceChild(newBtn, applyBtn);
                    
                    newBtn.addEventListener('click', function() {
                        applyRepair(sensorId, repairedData);
                    });
                }
                
                // 导出数据按钮
                const exportBtn = document.getElementById('export-repair-btn');
                if (exportBtn) {
                    const newBtn = exportBtn.cloneNode(true);
                    exportBtn.parentNode.replaceChild(newBtn, exportBtn);
                    
                    newBtn.addEventListener('click', function() {
                        exportRepairData(sensorId, repairedData);
                    });
                }
                
                // 新增继续修复按钮
                let continueBtn = document.getElementById('continue-repair-btn');
                
                // 如果按钮不存在，则创建一个
                if (!continueBtn) {
                    continueBtn = document.createElement('button');
                    continueBtn.id = 'continue-repair-btn';
                    continueBtn.className = 'btn btn-primary btn-sm';
                    continueBtn.innerHTML = '<i class="fas fa-sync-alt"></i> 继续修复其他传感器';
                    
                    // 将按钮添加到按钮组
                    const btnGroup = document.querySelector('.repair-btn-group');
                    if (btnGroup) {
                        btnGroup.appendChild(continueBtn);
                    }
                } else {
                    // 如果按钮存在，clone一次以移除旧的事件监听器
                    const newBtn = continueBtn.cloneNode(true);
                    continueBtn.parentNode.replaceChild(newBtn, continueBtn);
                    continueBtn = newBtn;
                }
                
                // 添加点击事件，显示传感器选择界面
                continueBtn.addEventListener('click', function() {
                    showSensorSelectionForNextRepair();
                });
            } catch (error) {
                console.error('设置修复按钮事件时出错:', error);
            }
        }
        
        // 显示传感器选择界面以选择下一个要修复的传感器
        function showSensorSelectionForNextRepair() {
            try {
                // 获取修复内容和控制区域
                const repairContent = document.getElementById('repair-content');
                const repairControl = document.getElementById('repair-control');
                
                // 隐藏结果内容，显示控制区域
                if (repairContent) repairContent.style.display = 'none';
                if (repairControl) repairControl.style.display = 'block';
                
                // 获取异常传感器分组
                const anomalySensorGroups = getAnomalySensorGroups();
                
                // 更新传感器选择下拉菜单
                updateSensorSelectForNextRepair(anomalySensorGroups);
                
                // 显示提示消息
                const repairHeader = document.querySelector('.repair-header h3');
                if (repairHeader) {
                    repairHeader.textContent = '选择下一个要修复的传感器';
                }
                
                // 向下滚动到控制区域
                repairControl.scrollIntoView({ behavior: 'smooth' });
            } catch (error) {
                console.error('显示传感器选择界面时出错:', error);
            }
        }

        // 更新传感器选择下拉菜单
        function updateSensorSelectForNextRepair(sensorGroups) {
            try {
                // 获取传感器选择下拉菜单
                const sensorSelect = document.getElementById('repair-sensor-select');
                if (!sensorSelect) return;
                
                // 清空下拉菜单
                sensorSelect.innerHTML = '<option value="">-- 请选择传感器 --</option>';
                
                // 添加有异常的传感器到下拉菜单
                let hasAnomalies = false;
                
                if (sensorGroups) {
                    Object.keys(sensorGroups).forEach(sensorId => {
                        if (sensorGroups[sensorId].anomalies && sensorGroups[sensorId].anomalies.length > 0) {
                            const option = document.createElement('option');
                            option.value = sensorId;
                            option.textContent = `${sensorId} (${sensorGroups[sensorId].anomalies.length}个异常)`;
                            sensorSelect.appendChild(option);
                            hasAnomalies = true;
                        }
                    });
                }
                
                // 如果没有异常传感器，显示提示
                if (!hasAnomalies) {
                    const option = document.createElement('option');
                    option.value = "";
                    option.textContent = "没有更多异常传感器需要修复";
                    option.disabled = true;
                    sensorSelect.appendChild(option);
                    
                    // 禁用开始修复按钮
                    const startRepairBtn = document.getElementById('start-repair-btn');
                    if (startRepairBtn) startRepairBtn.disabled = true;
                } else {
                    // 启用开始修复按钮
                    const startRepairBtn = document.getElementById('start-repair-btn');
                    if (startRepairBtn) startRepairBtn.disabled = false;
                }
            } catch (error) {
                console.error('更新传感器选择下拉菜单时出错:', error);
            }
        }

        // 应用修复
        function applyRepair(sensorId, repairedData) {
            try {
                // 确认应用修复
                if (!confirm(`确定要应用这些修复数据到传感器 ${sensorId} 吗？`)) {
                    return;
                }
                
                let updatedCount = 0;
                
                // 修改原始数据中的异常值
                repairedData.forEach(item => {
                    const index = item.index;
                    
                    // 查找要修复的数据点
                    const dataPoint = window.sensorData.find((point, idx) => 
                        point.sensorId === sensorId && 
                        point.timestamp === item.timestamp);
                    
                    if (dataPoint) {
                        // 记录原始值
                        dataPoint.originalValue = dataPoint.value;
                        
                        // 应用修复值
                        dataPoint.value = parseFloat(item.repairedValue);
                        dataPoint.status = 'repaired';
                        
                        updatedCount++;
                    }
                });
                
                // 更新数据表格和图表
                displayData();
                createChart();
                
                // 修改异常检测结果
                const anomalySensorGroups = getAnomalySensorGroups();
                if (anomalySensorGroups && anomalySensorGroups[sensorId]) {
                    // 减少异常计数
                    anomalySensorGroups[sensorId].anomalies = [];
                    
                    // 重新显示异常结果
                    const totalAnomalies = countTotalAnomalies(anomalySensorGroups);
                    const sensorAnomalyCount = countSensorAnomalies(anomalySensorGroups);
                    
                    displayAnomalyResults(anomalySensorGroups, totalAnomalies, sensorAnomalyCount);
                }
                
                // 显示成功消息
                alert(`成功修复 ${updatedCount} 个数据点`);
                
                // 询问是否继续修复其他传感器
                if (confirm('数据已应用成功。是否要继续修复其他传感器？')) {
                    showSensorSelectionForNextRepair();
                } else {
                    // 切换到数据可视化标签
                    document.querySelector('.tab[data-tab="visualization"]').click();
                }
                
            } catch (error) {
                console.error('应用修复时出错:', error);
                alert('应用修复时出错: ' + error.message);
            }
        }
        
        // 导出修复数据
        function exportRepairData(sensorId, repairedData) {
            try {
                if (!repairedData || repairedData.length === 0) {
                    alert('没有可导出的修复数据!');
                    return;
                }
                
                // 创建CSV内容
                let csvContent = "数据行,传感器ID,时间戳,原始值,修复值\n";
                
                repairedData.forEach((item, index) => {
                    csvContent += `${index + 1},${item.sensorId},${item.timestamp},${item.originalValue},${item.repairedValue}\n`;
                });
                
                // 创建下载链接
                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                
                link.setAttribute('href', url);
                link.setAttribute('download', `${sensorId}_修复数据_${new Date().toISOString().split('T')[0]}.csv`);
                link.style.display = 'none';
                
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                console.log('修复数据已导出');
            } catch (error) {
                console.error('导出修复数据时出错:', error);
                alert('导出修复数据时出错: ' + error.message);
            }
        }
        
        // 获取异常传感器分组
        function getAnomalySensorGroups() {
            // 此处应该从全局状态或DOM中获取异常检测结果
            // 为简化实现，这里直接重新检测一次
            
            if (!window.sensorData || window.sensorData.length === 0) {
                return null;
            }
            
            const sensorGroups = {};
            
            window.sensorData.forEach(dataPoint => {
                if (!sensorGroups[dataPoint.sensorId]) {
                    sensorGroups[dataPoint.sensorId] = {
                        type: dataPoint.sensorType,
                        values: [],
                        timestamps: [],
                        anomalies: []
                    };
                }
                
                sensorGroups[dataPoint.sensorId].values.push(dataPoint.value);
                sensorGroups[dataPoint.sensorId].timestamps.push(dataPoint.timestamp);
            });
            
            // 检测异常
            Object.keys(sensorGroups).forEach(sensorId => {
                const group = sensorGroups[sensorId];
                const values = group.values;
                
                // 应用DBScan方法检测异常
                const anomalyIndices = DBScan(values);
                
                // 如果有异常，标记
                if (anomalyIndices && anomalyIndices.length > 0) {
                    anomalyIndices.forEach(index => {
                        // 确保索引在有效范围内
                        if (index >= 0 && index < values.length) {
                            // 计算异常类型
                            const anomalyType = determineAnomalyType(index, values, 3.0);
                            
                            group.anomalies.push({
                                index: index,
                                value: values[index],
                                timestamp: group.timestamps[index],
                                score: 0,
                                type: anomalyType
                            });
                        }
                    });
                }
            });
            
            return sensorGroups;
        }
        
        // 计算异常总数
        function countTotalAnomalies(sensorGroups) {
            let total = 0;
            
            Object.keys(sensorGroups).forEach(sensorId => {
                total += sensorGroups[sensorId].anomalies.length;
            });
            
            return total;
        }
        
        // 计算有异常的传感器数量
        function countSensorAnomalies(sensorGroups) {
            let count = 0;
            
            Object.keys(sensorGroups).forEach(sensorId => {
                if (sensorGroups[sensorId].anomalies.length > 0) {
                    count++;
                }
            });
            
            return count;
        }
        
        // 帮助函数：从传感器ID获取传感器类型
        function getSensorTypeFromId(sensorId, defaultType) {
            // 如果有默认类型，直接使用
            if (defaultType) return defaultType;
            
            // 尝试从数据中找到传感器类型
            const sensor = window.sensorData.find(s => s.sensorId === sensorId);
            if (sensor && sensor.sensorType) {
                return sensor.sensorType;
            }
            
            // 尝试从ID中推断类型
            if (sensorId.includes('TMP') || sensorId.includes('TEMP')) return '温度';
            if (sensorId.includes('STR') || sensorId.includes('STRAIN')) return '应变';
            if (sensorId.includes('VIB')) return '振动';
            if (sensorId.includes('INC') || sensorId.includes('TILT')) return '倾角';
            
            // 无法确定类型时使用默认类型
            return '未知类型';
        }

        // 文档加载完成后执行
        document.addEventListener('DOMContentLoaded', function() {
            console.log("页面已加载完成...");
            
            // 初始化UI组件
            initUI();
            
            // 绑定事件
            bindEvents();
            
            // 初始化可折叠元素
            initCollapsibleElements();
            
            // 模拟轻微延迟后显示界面，给用户更好的加载感受
            setTimeout(function() {
                document.body.classList.add('loaded');
            }, 300);
        });

        // 初始化可折叠元素
        function initCollapsibleElements() {
            try {
                console.log("初始化可折叠元素...");
                
                // 绑定异常图表折叠按钮事件
                const toggleButton = document.getElementById('toggle-anomaly-charts');
                const chartContainer = document.getElementById('anomaly-chart-container');
                
                if (toggleButton && chartContainer) {
                    toggleButton.addEventListener('click', function() {
                        console.log("切换异常图表显示状态");
                        
                        if (chartContainer.style.display === 'none') {
                            chartContainer.style.display = 'block';
                            toggleButton.querySelector('.material-icons').textContent = 'expand_less';
                        } else {
                            chartContainer.style.display = 'none';
                            toggleButton.querySelector('.material-icons').textContent = 'expand_more';
                        }
                    });
                }
            } catch (error) {
                console.error("初始化可折叠元素时出错:", error);
            }
        }

        // 初始化UI组件
        function initUI() {
            try {
                console.log("初始化UI组件...");
                
                // 初始化示例数据下载链接
                const downloadLink = document.getElementById('downloadExample');
                if (downloadLink) {
                    downloadLink.addEventListener('click', generateExampleFile);
                }
                
                // 绑定标签页切换事件
                document.querySelectorAll('.tab').forEach(tab => {
                    tab.addEventListener('click', function() {
                        const tabId = this.getAttribute('data-tab');
                        
                        // 更新标签页状态
                        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                        this.classList.add('active');
                        
                        // 更新内容区域
                        document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
                        document.getElementById(`${tabId}-tab`).classList.add('active');
                    });
                });
                
                // 初始化可折叠元素
                initCollapsibleElements();
            } catch (error) {
                console.error("初始化UI组件时出错:", error);
            }
        }

        // 尝试重新连接离线摄像头
        function attemptReconnect(cameraId) {
            try {
                console.log(`尝试重新连接摄像头 #${cameraId}`);
                
                // 查找摄像头元素
                const cameraItem = document.querySelector(`.camera-item[data-camera-id="${cameraId}"]`);
                if (!cameraItem) {
                    console.error(`未找到摄像头 #${cameraId} 的元素`);
                    return;
                }
                
                // 检查摄像头是否离线
                const cameraStatus = cameraItem.dataset.status;
                if (cameraStatus !== 'offline') {
                    console.log(`摄像头 #${cameraId} 不是离线状态，无需重连`);
                    return;
                }
                
                showActionFeedback(cameraId, `正在尝试重新连接摄像头 #${cameraId}...`);
                
                // 查找摄像头占位符
                const placeholder = cameraItem.querySelector('.camera-placeholder');
                if (placeholder) {
                    const icon = placeholder.querySelector('.camera-icon');
                    const message = placeholder.querySelector('.camera-message');
                    
                    if (icon) icon.innerHTML = '<span class="material-icons">sync</span>';
                    if (message) message.textContent = '正在尝试重新连接...';
                }
                
                // 模拟重连过程
                setTimeout(() => {
                    // 随机决定重连是否成功
                    const success = Math.random() > 0.7; // 30% 成功率
                    
                    if (success) {
                        // 重连成功
                        cameraItem.dataset.status = 'online';
                        const cameraView = cameraItem.querySelector('.camera-view');
                        if (cameraView) {
                            cameraView.classList.remove('offline');
                        }
                        
                        // 更新状态显示
                        const statusBadge = cameraItem.querySelector('.camera-status');
                        if (statusBadge) {
                            statusBadge.textContent = '在线';
                            statusBadge.className = 'camera-status online';
                        }
                        
                        // 更新占位符
                        if (placeholder) {
                            const icon = placeholder.querySelector('.camera-icon');
                            const message = placeholder.querySelector('.camera-message');
                            
                            if (icon) icon.innerHTML = '<span class="material-icons">videocam</span>';
                            if (message) message.textContent = '点击查看直播';
                        }
                        
                        showActionFeedback(cameraId, `摄像头 #${cameraId} 已成功重新连接`);
                        
                        // 自动打开视频流
                        setTimeout(() => {
                            viewCamera(cameraId);
                        }, 1000);
                        
                    } else {
                        // 重连失败
                        // 恢复原状态
                        if (placeholder) {
                            const icon = placeholder.querySelector('.camera-icon');
                            const message = placeholder.querySelector('.camera-message');
                            
                            if (icon) icon.innerHTML = '<span class="material-icons">videocam_off</span>';
                            if (message) message.textContent = '摄像头离线 (点击重试)';
                        }
                        
                        showActionFeedback(cameraId, `摄像头 #${cameraId} 重新连接失败`);
                    }
                }, 3000); // 模拟3秒重连过程
                
            } catch (error) {
                console.error(`尝试重新连接摄像头 #${cameraId} 时出错:`, error);
            }
        }
        
        // 截图功能
        function takeSnapshot(cameraId) {
            try {
                console.log(`为摄像头 #${cameraId} 拍摄截图`);
                
                // 查找摄像头元素
                const cameraItem = document.querySelector(`.camera-item[data-camera-id="${cameraId}"]`);
                if (!cameraItem) {
                    console.error(`未找到摄像头 #${cameraId} 的元素`);
                    return;
                }
                
                // 检查摄像头状态
                const cameraStatus = cameraItem.dataset.status;
                if (cameraStatus === 'offline') {
                    showActionFeedback(cameraId, `无法截图：摄像头 #${cameraId} 当前离线`);
                    return;
                }
                
                // 查找视频元素
                const videoElement = document.getElementById(`video-stream-${cameraId}`);
                if (videoElement && videoElement.readyState >= 2) { // HAVE_CURRENT_DATA 或更高
                    try {
                        // 创建Canvas
                        const canvas = document.createElement('canvas');
                        canvas.width = videoElement.videoWidth || 640;
                        canvas.height = videoElement.videoHeight || 480;
                        
                        // 绘制视频帧到Canvas
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height);
                        
                        // 添加水印
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                        ctx.font = '14px Arial';
                        const timestamp = new Date().toLocaleString();
                        ctx.fillText(`摄像头 #${cameraId} - ${timestamp}`, 10, canvas.height - 10);
                        
                        // 将Canvas转换为图片URL
                        const imageUrl = canvas.toDataURL('image/png');
                        
                        // 创建下载链接
                        const link = document.createElement('a');
                        link.href = imageUrl;
                        link.download = `摄像头${cameraId}_截图_${new Date().getTime()}.png`;
                        
                        // 模拟点击下载
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        
                        showActionFeedback(cameraId, `已保存摄像头 #${cameraId} 的截图`);
                    } catch (error) {
                        console.error('截图创建失败:', error);
                        showActionFeedback(cameraId, `截图失败: ${error.message}`);
                    }
                } else {
                    // 如果视频元素不存在或未加载，则先连接摄像头然后再截图
                    showActionFeedback(cameraId, `正在连接摄像头...`);
                    viewCamera(cameraId);
                    
                    // 等待视频加载后再截图
                    setTimeout(() => {
                        const videoElement = document.getElementById(`video-stream-${cameraId}`);
                        if (videoElement && videoElement.readyState >= 2) {
                            takeSnapshot(cameraId);
                        } else {
                            showActionFeedback(cameraId, `无法截图：视频流未就绪`);
                        }
                    }, 2000);
                }
                
            } catch (error) {
                console.error(`为摄像头 #${cameraId} 拍摄截图时出错:`, error);
                showActionFeedback(cameraId, `截图错误: ${error.message}`);
            }
        }

        // 绑定事件处理函数
        function bindEvents() {
            try {
                console.log("绑定事件处理函数...");
                
                // 绑定上传按钮事件
                const uploadBtn = document.getElementById('uploadBtn');
                if (uploadBtn) {
                    uploadBtn.addEventListener('click', function() {
                        document.getElementById('fileInput').click();
                    });
                }
                
                // 绑定文件输入事件
                const fileInput = document.getElementById('fileInput');
                if (fileInput) {
                    fileInput.addEventListener('change', handleFileUpload);
                }
                
                // 绑定检测按钮事件
                const detectBtn = document.getElementById('detectBtn');
                if (detectBtn) {
                    detectBtn.addEventListener('click', startDetection);
                }
                
                // 绑定清空按钮事件
                const clearBtn = document.getElementById('clearBtn');
                if (clearBtn) {
                    clearBtn.addEventListener('click', clearResults);
                }
                
                console.log("事件绑定完成");
            } catch (error) {
                console.error("绑定事件处理函数时出错:", error);
            }
        }
    </script>

    <!-- 登录验证功能 -->
    <script>
        // 设置固定的登录凭证
        const ADMIN_USERNAME = 'admin';
        const ADMIN_PASSWORD = 'bridge2024';
        
        // DOM元素加载完成后执行初始化
        document.addEventListener('DOMContentLoaded', function() {
            initLoginSystem();
        });
        
        // 初始化登录系统
        function initLoginSystem() {
            try {
                console.log('初始化登录系统...');
                
                // 获取登录元素
                const loginModal = document.getElementById('loginModal');
                const loginForm = document.getElementById('loginForm');
                const errorMessage = document.getElementById('errorMessage');
                const logoutBtn = document.getElementById('logoutBtn');
                
                if (!loginModal || !loginForm) {
                    console.error('找不到登录模态框或表单元素');
                    return;
                }
                
                // 检查并设置登录状态
                if (localStorage.getItem('isLoggedIn') === 'true') {
                    loginModal.style.display = 'none';
                    const username = localStorage.getItem('username') || 'admin';
                    
                    // 更新用户信息显示
                    const userAvatar = document.getElementById('userAvatar');
                    const userDisplay = document.getElementById('userDisplay');
                    
                    if (userAvatar) userAvatar.textContent = username.charAt(0).toUpperCase();
                    if (userDisplay) userDisplay.textContent = `监测员：${username}`;
                    
                    console.log('用户已登录，用户名:', username);
                } else {
                    loginModal.style.display = 'flex';
                    console.log('用户未登录，显示登录界面');
                }
                
                // 绑定登录表单提交事件
                loginForm.addEventListener('submit', function(e) {
                    e.preventDefault();
                    
                    const usernameInput = document.getElementById('username');
                    const passwordInput = document.getElementById('password');
                    
                    if (!usernameInput || !passwordInput) {
                        console.error('找不到用户名或密码输入框');
                        return;
                    }
                    
                    const username = usernameInput.value;
                    const password = passwordInput.value;
                    
                    if (username === ADMIN_USERNAME && password === ADMIN_PASSWORD) {
                        // 登录成功
                        localStorage.setItem('isLoggedIn', 'true');
                        localStorage.setItem('username', username);
                        
                        // 隐藏登录模态框
                        loginModal.style.display = 'none';
                        
                        // 更新用户信息显示
                        const userAvatar = document.getElementById('userAvatar');
                        const userDisplay = document.getElementById('userDisplay');
                        
                        if (userAvatar) userAvatar.textContent = username.charAt(0).toUpperCase();
                        if (userDisplay) userDisplay.textContent = `监测员：${username}`;
                        
                        // 清空表单
                        loginForm.reset();
                        if (errorMessage) errorMessage.textContent = '';
                        
                        console.log('登录成功');
                    } else {
                        // 登录失败
                        if (errorMessage) errorMessage.textContent = '用户名或密码错误，请重试。';
                        
                        // 清空密码字段
                        if (passwordInput) passwordInput.value = '';
                        
                        console.log('登录失败：用户名或密码错误');
                    }
                });
                
                // 绑定登出按钮事件
                if (logoutBtn) {
                    logoutBtn.addEventListener('click', function() {
                        // 清除登录状态
                        localStorage.removeItem('isLoggedIn');
                        localStorage.removeItem('username');
                        
                        // 显示登录模态框
                        if (loginModal) loginModal.style.display = 'flex';
                        
                        // 提示用户已登出
                        alert('您已成功登出系统');
                        
                        console.log('用户已登出系统');
                    });
                }
                
                console.log('登录系统初始化完成');
            } catch (error) {
                console.error('初始化登录系统时出错:', error);
            }
        }
    </script>
    
    <!-- 项目信息 -->
    <div class="project-info-container">
        <div class="project-info">
            <div class="project-item">
                <strong>项目依托：</strong>国家级"大学生创新创业训练计划"（202410183209）
            </div>
            <div class="project-item">
                <strong>指导老师：</strong>吉林大学电子科学与工程学院 高通
            </div>
            <div class="project-item">
                <strong>开发团队：</strong>吉林大学电子科学与工程学院本科生 王晓楠，毕月榕，隋智垚，黄清，王雨芳
            </div>
            <div class="project-item">
                <strong>管理员邮箱：</strong>biyr1922@mails.jlu.edu.cn
            </div>
        </div>
    </div>
    
    <!-- 系统补丁脚本 - 修复常见问题 -->
    <script src="js/bridge-patch.js"></script>
    
    <!-- 紧急修复脚本 - 在所有脚本加载后执行 -->
    <script src="js/emergency-fix.js"></script>
    
    <!-- Chart.js备用实现 - 确保图表正常显示 -->
    <script src="js/chart-fallback.js"></script>
    
    <!-- 本地资源检查与修复脚本 -->
    <script>
    (function() {
        console.log('执行最终本地资源检查与修复...');
        
        // 确保noMonitorMessage定义
        if (typeof window.noMonitorMessage === 'undefined') {
            console.warn('noMonitorMessage未定义，创建空对象');
            window.noMonitorMessage = { 
                style: { display: 'none' }
            };
        }
        
        // 检查Chart.js是否已加载
        if (typeof Chart === 'undefined') {
            console.error('Chart.js未加载，尝试再次加载...');
            
            // 强制加载本地Chart.js
            var script = document.createElement('script');
            script.src = 'js/chart.min.js';
            document.head.appendChild(script);
            
            // 强制加载备用实现
            script = document.createElement('script');
            script.src = 'js/chart-fallback.js';
            document.head.appendChild(script);
        }
        
        // 处理handleFileUpload未定义问题
        if (typeof window.handleFileUpload !== 'function') {
            console.warn('handleFileUpload函数未定义，创建兼容函数');
            window.handleFileUpload = function(event) {
                try {
                    const fileInput = event.target;
                    if (!fileInput || !fileInput.files || fileInput.files.length === 0) {
                        console.warn('未选择文件');
                        return;
                    }
                    
                    const file = fileInput.files[0];
                    console.log(`已选择文件: ${file.name} (${formatFileSize(file.size)})`);
                    
                    // 显示文件信息
                    const fileInfo = document.getElementById('fileInfo');
                    if (fileInfo) {
                        fileInfo.textContent = `已选择文件: ${file.name} (${formatFileSize(file.size)})`;
                    }
                    
                    // 启用上传按钮
                    const uploadButton = document.getElementById('uploadButton');
                    if (uploadButton) {
                        uploadButton.disabled = false;
                    }
                } catch (error) {
                    console.error('处理文件上传时出错:', error);
                }
            };
            
            // 如果formatFileSize未定义，也添加该函数
            if (typeof window.formatFileSize !== 'function') {
                window.formatFileSize = function(bytes) {
                    if (bytes === 0) return '0 Bytes';
                    const k = 1024;
                    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                    const i = Math.floor(Math.log(bytes) / Math.log(k));
                    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
                };
            }
        }
        
        // 移除所有网络资源引用
        try {
            const networkPatterns = [
                'cdn.jsdelivr.net',
                'fonts.googleapis.com',
                'cdnjs.cloudflare.com',
                'unpkg.com'
            ];
            
            // 移除脚本标签
            const scripts = document.querySelectorAll('script[src]');
            scripts.forEach(function(script) {
                const src = script.getAttribute('src');
                if (src && networkPatterns.some(pattern => src.includes(pattern))) {
                    console.warn('移除网络脚本:', src);
                    script.parentNode.removeChild(script);
                }
            });
            
            // 移除样式表
            const links = document.querySelectorAll('link[href]');
            links.forEach(function(link) {
                const href = link.getAttribute('href');
                if (href && networkPatterns.some(pattern => href.includes(pattern))) {
                    console.warn('移除网络样式:', href);
                    link.parentNode.removeChild(link);
                }
            });
        } catch (error) {
            console.error('移除网络资源时出错:', error);
        }
        
        console.log('最终本地资源检查与修复完成');
    })();
    </script>
</body>
</html> 