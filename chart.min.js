// Chart.js v3.7.0 - 简化版实现
console.log('Chart.js加载成功 - 版本: 3.7.0');

// 创建Chart全局对象
var Chart = window.Chart = function(context, config) {
    if (!(this instanceof Chart)) {
        return new Chart(context, config);
    }
    
    this.id = 'chart_' + Math.floor(Math.random() * 100000);
    this.ctx = typeof context === 'string' ? document.getElementById(context).getContext('2d') : context;
    this.canvas = this.ctx.canvas;
    this.config = config || {};
    this.type = config.type || 'line';
    this.data = config.data || { datasets: [], labels: [] };
    this.options = config.options || {};
    
    console.log('创建Chart实例: ' + this.type + ', 数据集: ' + (this.data.datasets || []).length);
    
    // 初始化图表
    this._init();
    
    // 方法定义
    this.update = function() {
        console.log('更新图表: ' + this.id);
        this._clear();
        this._draw();
        return this;
    };
    
    this.destroy = function() {
        console.log('销毁图表: ' + this.id);
        this._clear();
        this.canvas.removeEventListener('mousemove', this._handleMouseMove);
        return this;
    };
    
    this.resize = function() {
        console.log('调整图表大小: ' + this.id);
        return this.update();
    };
    
    // 自动更新一次
    this.update();
    
    return this;
};

// 初始化方法
Chart.prototype._init = function() {
    var self = this;
    this._tooltip = {
        x: 0,
        y: 0,
        visible: false,
        text: ''
    };
    
    // 添加事件监听
    this.canvas.addEventListener('mousemove', this._handleMouseMove = function(e) {
        var rect = self.canvas.getBoundingClientRect();
        var x = e.clientX - rect.left;
        var y = e.clientY - rect.top;
        self._handleTooltip(x, y);
    });
};

// 清除画布
Chart.prototype._clear = function() {
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
};

// 处理提示框
Chart.prototype._handleTooltip = function(x, y) {
    // 简单版本：确定最近的数据点并显示提示
    if (this.type === 'line') {
        var datasets = this.data.datasets;
        var labels = this.data.labels;
        if (!datasets.length) return;
        
        var padding = this._getPadding();
        var chartWidth = this.canvas.width - padding.left - padding.right;
        var pointWidth = chartWidth / (labels.length - 1);
        var dataIndex = Math.round((x - padding.left) / pointWidth);
        
        if (dataIndex >= 0 && dataIndex < labels.length) {
            this._tooltip.visible = true;
            this._tooltip.x = padding.left + dataIndex * pointWidth;
            
            var text = labels[dataIndex];
            datasets.forEach(function(dataset) {
                var value = dataset.data[dataIndex];
                if (value !== undefined) {
                    text += '\n' + dataset.label + ': ' + value.toFixed(1);
                }
            });
            
            this._tooltip.text = text;
            this.update();
        }
    }
};

// 获取内边距
Chart.prototype._getPadding = function() {
    return {
        top: 30,
        right: 30,
        bottom: 30,
        left: 50
    };
};

// 绘制图表
Chart.prototype._draw = function() {
    if (this.type === 'line') {
        this._drawLineChart();
    } else if (this.type === 'bar') {
        this._drawBarChart();
    } else if (this.type === 'pie') {
        this._drawPieChart();
    }
};

// 绘制线形图
Chart.prototype._drawLineChart = function() {
    var ctx = this.ctx;
    var datasets = this.data.datasets;
    var labels = this.data.labels;
    var options = this.options;
    
    if (!datasets.length || !labels.length) {
        return;
    }
    
    var padding = this._getPadding();
    var chartWidth = this.canvas.width - padding.left - padding.right;
    var chartHeight = this.canvas.height - padding.top - padding.bottom;
    
    // 计算Y轴范围
    var yMin = options.scales && options.scales.y && options.scales.y.min !== undefined ? 
        options.scales.y.min : Number.MAX_VALUE;
    var yMax = options.scales && options.scales.y && options.scales.y.max !== undefined ? 
        options.scales.y.max : Number.MIN_VALUE;
    
    if (yMin === Number.MAX_VALUE || yMax === Number.MIN_VALUE) {
        datasets.forEach(function(dataset) {
            var data = dataset.data;
            for (var i = 0; i < data.length; i++) {
                if (data[i] < yMin) yMin = data[i];
                if (data[i] > yMax) yMax = data[i];
            }
        });
        
        // 稍微扩展范围
        var range = yMax - yMin;
        yMin = Math.max(0, yMin - range * 0.1);
        yMax = yMax + range * 0.1;
    }
    
    // 绘制坐标轴
    ctx.strokeStyle = '#ccc';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(padding.left, padding.top);
    ctx.lineTo(padding.left, this.canvas.height - padding.bottom);
    ctx.lineTo(this.canvas.width - padding.right, this.canvas.height - padding.bottom);
    ctx.stroke();
    
    // 绘制Y轴刻度
    var yStep = options.scales && options.scales.y && options.scales.y.stepSize ? 
        options.scales.y.stepSize : (yMax - yMin) / 5;
    var ySteps = Math.ceil((yMax - yMin) / yStep);
    
    ctx.fillStyle = '#666';
    ctx.font = '12px Arial';
    ctx.textAlign = 'right';
    ctx.textBaseline = 'middle';
    
    for (var i = 0; i <= ySteps; i++) {
        var value = yMin + i * yStep;
        var y = this.canvas.height - padding.bottom - (value - yMin) / (yMax - yMin) * chartHeight;
        
        ctx.fillText(value.toFixed(1), padding.left - 10, y);
        
        // 绘制网格线
        ctx.strokeStyle = '#eee';
        ctx.beginPath();
        ctx.moveTo(padding.left, y);
        ctx.lineTo(this.canvas.width - padding.right, y);
        ctx.stroke();
    }
    
    // 绘制X轴刻度
    var maxLabels = options.scales && options.scales.x && options.scales.x.maxTicksLimit ? 
        options.scales.x.maxTicksLimit : labels.length;
    var step = Math.ceil(labels.length / maxLabels);
    
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    
    for (var i = 0; i < labels.length; i += step) {
        var x = padding.left + i / (labels.length - 1) * chartWidth;
        ctx.fillText(labels[i], x, this.canvas.height - padding.bottom + 10);
    }
    
    // 绘制数据集
    datasets.forEach(function(dataset) {
        var data = dataset.data;
        
        // 绘制填充区域
        if (dataset.fill) {
            ctx.fillStyle = dataset.backgroundColor || 'rgba(0,0,0,0.1)';
            ctx.beginPath();
            ctx.moveTo(padding.left, this.canvas.height - padding.bottom);
            
            for (var i = 0; i < data.length; i++) {
                var x = padding.left + i / (data.length - 1) * chartWidth;
                var y = this.canvas.height - padding.bottom - (data[i] - yMin) / (yMax - yMin) * chartHeight;
                
                if (i === 0) {
                    ctx.moveTo(x, this.canvas.height - padding.bottom);
                    ctx.lineTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            
            ctx.lineTo(padding.left + chartWidth, this.canvas.height - padding.bottom);
            ctx.closePath();
            ctx.fill();
        }
        
        // 绘制线条
        ctx.strokeStyle = dataset.borderColor || 'rgb(0,0,0)';
        ctx.lineWidth = dataset.borderWidth || 2;
        ctx.lineJoin = 'round';
        
        // 处理线条张力
        if (dataset.tension !== undefined && dataset.tension > 0) {
            this._drawCurve(data, padding, chartWidth, chartHeight, yMin, yMax);
        } else {
            ctx.beginPath();
            
            for (var i = 0; i < data.length; i++) {
                var x = padding.left + i / (data.length - 1) * chartWidth;
                var y = this.canvas.height - padding.bottom - (data[i] - yMin) / (yMax - yMin) * chartHeight;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            
            ctx.stroke();
        }
        
        // 绘制数据点
        if (dataset.pointRadius) {
            var radius = dataset.pointRadius;
            var hoverRadius = dataset.pointHoverRadius || radius * 1.5;
            
            for (var i = 0; i < data.length; i++) {
                var x = padding.left + i / (data.length - 1) * chartWidth;
                var y = this.canvas.height - padding.bottom - (data[i] - yMin) / (yMax - yMin) * chartHeight;
                
                ctx.fillStyle = dataset.pointBackgroundColor || dataset.borderColor || 'rgb(0,0,0)';
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = dataset.pointBorderColor || '#fff';
                ctx.lineWidth = dataset.pointBorderWidth || 1.5;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.stroke();
            }
        }
    }, this);
    
    // 绘制图例
    if (options.plugins && options.plugins.legend && options.plugins.legend.display !== false) {
        var legendX = padding.left + 10;
        var legendY = padding.top / 2;
        
        datasets.forEach(function(dataset, index) {
            var color = dataset.borderColor || Chart.defaults.color[index % Chart.defaults.color.length];
            var label = dataset.label || '';
            
            ctx.fillStyle = color;
            ctx.fillRect(legendX, legendY - 6, 20, 12);
            
            ctx.fillStyle = '#666';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle';
            ctx.fillText(label, legendX + 25, legendY);
            
            legendX += ctx.measureText(label).width + 50;
        });
    }
    
    // 绘制提示框
    if (this._tooltip.visible) {
        var text = this._tooltip.text.split('\n');
        var lineHeight = 18;
        var padding = 8;
        var width = 0;
        
        ctx.font = '12px Arial';
        
        // 计算提示框宽度
        for (var i = 0; i < text.length; i++) {
            var textWidth = ctx.measureText(text[i]).width;
            width = Math.max(width, textWidth);
        }
        
        width += padding * 2;
        var height = text.length * lineHeight + padding * 2;
        
        // 绘制提示框
        ctx.fillStyle = 'rgba(0,0,0,0.7)';
        ctx.beginPath();
        ctx.roundRect(this._tooltip.x - width / 2, 10, width, height, 5);
        ctx.fill();
        
        // 绘制文本
        ctx.fillStyle = '#fff';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        
        for (var i = 0; i < text.length; i++) {
            ctx.fillText(text[i], this._tooltip.x, 10 + padding + i * lineHeight);
        }
    }
};

// 绘制曲线
Chart.prototype._drawCurve = function(data, padding, chartWidth, chartHeight, yMin, yMax) {
    var ctx = this.ctx;
    var points = [];
    
    // 准备点数据
    for (var i = 0; i < data.length; i++) {
        var x = padding.left + i / (data.length - 1) * chartWidth;
        var y = this.canvas.height - padding.bottom - (data[i] - yMin) / (yMax - yMin) * chartHeight;
        points.push({ x: x, y: y });
    }
    
    ctx.beginPath();
    ctx.moveTo(points[0].x, points[0].y);
    
    // 使用贝塞尔曲线绘制
    for (var i = 1; i < points.length; i++) {
        var prev = points[i - 1];
        var curr = points[i];
        
        var cp1x = prev.x + (curr.x - prev.x) / 3;
        var cp1y = prev.y;
        var cp2x = curr.x - (curr.x - prev.x) / 3;
        var cp2y = curr.y;
        
        ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, curr.x, curr.y);
    }
    
    ctx.stroke();
};

// 扩展CanvasRenderingContext2D
if (!CanvasRenderingContext2D.prototype.roundRect) {
    CanvasRenderingContext2D.prototype.roundRect = function(x, y, width, height, radius) {
        if (typeof radius === 'undefined') {
            radius = 5;
        }
        
        this.beginPath();
        this.moveTo(x + radius, y);
        this.lineTo(x + width - radius, y);
        this.quadraticCurveTo(x + width, y, x + width, y + radius);
        this.lineTo(x + width, y + height - radius);
        this.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
        this.lineTo(x + radius, y + height);
        this.quadraticCurveTo(x, y + height, x, y + height - radius);
        this.lineTo(x, y + radius);
        this.quadraticCurveTo(x, y, x + radius, y);
        this.closePath();
        return this;
    };
}

// 静态属性和方法
Chart.defaults = {
    global: {
        defaultFontFamily: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
        defaultFontSize: 12,
        defaultFontStyle: 'normal',
        defaultFontColor: '#666'
    },
    color: [
        'rgb(255, 99, 132)',   // 红色
        'rgb(54, 162, 235)',   // 蓝色
        'rgb(255, 206, 86)',   // 黄色
        'rgb(75, 192, 192)',   // 青色
        'rgb(153, 102, 255)',  // 紫色
        'rgb(255, 159, 64)'    // 橙色
    ]
};

Chart.helpers = {
    // 辅助方法
    getRelativePosition: function(e, chart) {
        return {
            x: e.offsetX,
            y: e.offsetY
        };
    },
    color: {
        // 颜色辅助方法
        alpha: function(color, alpha) {
            if (color.indexOf('rgba') === 0) {
                return color.replace(/rgba\(([^,]+),([^,]+),([^,]+),[^)]+\)/, 'rgba($1,$2,$3,' + alpha + ')');
            } else if (color.indexOf('rgb') === 0) {
                return color.replace(/rgb\(([^,]+),([^,]+),([^)]+)\)/, 'rgba($1,$2,$3,' + alpha + ')');
            }
            return color;
        }
    }
};

Chart.version = '3.7.0'; 